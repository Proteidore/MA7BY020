{
  "hash": "79d4e1d81219d44fc5880d0bebac0e7b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R programming: generics\"\ndate: \"2025-03-21 15:52:02.128589\"\n\n\nformat:\n  html:\n    output-file: lab-progr.html\n  pdf:\n    output-file: lab-progr.pdf\n \nengine: knitr\n---\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| Ann√©e {{< var year >}}     |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstopifnot(\n  require(Hmisc),\n  require(skimr),\n  require(patchwork),\n  require(ggforce),\n  require(glue),\n  require(ggfortify),\n  require(broom),\n  require(tidyverse)\n)\n\ntidymodels::tidymodels_prefer(quiet = TRUE)\n\nold_theme <-theme_set(\n  theme_minimal(base_size=9, \n                base_family = \"Helvetica\")\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ngc <- options(ggplot2.discrete.colour=\"viridis\")\ngc <- options(ggplot2.discrete.fill=\"viridis\")\ngc <- options(ggplot2.continuous.fill=\"viridis\")\ngc <- options(ggplot2.continuous.colour=\"viridis\")\n```\n:::\n\n\n\n\n## Objectives\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(\n  require(rlang),\n  require(lobstr),\n  require(sloop),\n  require(devtools),\n  require(usethis),\n  require(testthat),\n  require(generics)\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: rlang\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: lobstr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: sloop\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: devtools\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: usethis\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: testthat\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: generics\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Generics and S3 classes\n\nLet us first create an instance of class `lm`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm0  <- lm(Gas ~ Insul * Temp, MASS::whiteside)\n```\n:::\n\n\n\n\n::: {.callout-note title='Question'} \n\n- What does function `class()` do? \n- Is it possible to belong to type `list`  and to class `lm` simultaneously?\n- In `R` what is an *attribute*? \n- How do we *set* and *get* attributes?  \n- What does function `inherits()` do?\n \n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(lm0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.list(lm0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(lm0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"contrasts\"     \"xlevels\"       \"call\"          \"terms\"        \n[13] \"model\"        \n\n$class\n[1] \"lm\"\n```\n\n\n:::\n\n```{.r .cell-code}\ninherits(lm0,\"list\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ninherits(lm0, \"lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n \n::: \n \n:::\n\n::: {.callout-note title='Question'} \n\nLoad package `sloop`.\n\n- What does `sloop::otype()` do? Apply it to an object of class `lm`.\n- What happens when we first `unclass()` the object?\n \n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::otype(lm0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"S3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::otype(unclass(lm0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"base\"\n```\n\n\n:::\n:::\n\n\n\n \n::: \n:::\n\n\n::: {.callout-note title='Question'} \n \n`sloop` exports functions `s3_class()` and `s3_get_method()`  \n\n- Apply `s3_class()` to all members of `lm0`\n- What is the `otype` of `autoplot()` applied to an object of class `lm`?\n- \n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_class(lm0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_get_method(autoplot.lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (object, which = c(1:3, 5), data = NULL, colour = \"#444444\", \n    size = NULL, linetype = NULL, alpha = NULL, fill = NULL, \n    shape = NULL, label = TRUE, label.label = \".label\", label.colour = \"#000000\", \n    label.alpha = NULL, label.size = NULL, label.angle = NULL, \n    label.family = NULL, label.fontface = NULL, label.lineheight = NULL, \n    label.hjust = NULL, label.vjust = NULL, label.repel = FALSE, \n    label.n = 3, smooth.colour = \"#0000FF\", smooth.linetype = \"solid\", \n    ad.colour = \"#888888\", ad.linetype = \"dashed\", ad.size = 0.2, \n    nrow = NULL, ncol = NULL, ...) \n{\n    p1 <- p2 <- p3 <- p4 <- p5 <- p6 <- NULL\n    dropInf <- function(x, h) {\n        if (any(isInf <- h >= 1)) {\n            warning(gettextf(\"not plotting observations with leverage one:\\n  %s\", \n                paste(which(isInf), collapse = \", \")), call. = FALSE, \n                domain = NA)\n            x[isInf] <- NaN\n        }\n        x\n    }\n    show <- rep(FALSE, 6)\n    show[which] <- TRUE\n    class(object$residuals) <- NULL\n    if (is.null(data)) {\n        plot.data <- ggplot2::fortify(object)\n    }\n    else {\n        plot.data <- ggplot2::fortify(object, data = data)\n    }\n    n <- nrow(plot.data)\n    plot.data$.index <- 1:n\n    plot.data$.label <- rownames(plot.data)\n    is_glm <- inherits(object, \"glm\")\n    r <- residuals(object)\n    w <- weights(object)\n    if (any(show[2L:6L])) {\n        s <- if (inherits(object, \"rlm\")) {\n            object$s\n        }\n        else if (is_glm) {\n            sqrt(summary(object)$dispersion)\n        }\n        else {\n            sqrt(stats::deviance(object)/stats::df.residual(object))\n        }\n        hii <- stats::lm.influence(object, do.coef = FALSE)$hat\n        r.hat <- range(hii, na.rm = TRUE)\n        is_const_lev <- all(r.hat == 0) || all(diff(r.hat) < \n            1e-10 * mean(hii, na.rm = TRUE))\n        fs <- dplyr::select_if(plot.data, function(x) is.character(x) | \n            is.factor(x))\n        fs[[\".label\"]] <- NULL\n        if (is_const_lev & ncol(fs) > 0) {\n            plot.data$.nf <- stringr::str_wrap(interaction(fs, \n                sep = \":\"), width = 10)\n        }\n        if (any(show[2L:3L])) {\n            plot.data$.wresid <- if (is.null(w)) {\n                r\n            }\n            else {\n                sqrt(w) * r\n            }\n            plot.data$.wstdresid <- plot.data$.wresid/(s * sqrt(1 - \n                hii))\n        }\n        if (show[2L]) {\n            ylim <- range(plot.data$.wstdresid, na.rm = TRUE)\n            ylim[2L] <- ylim[2L] + diff(ylim) * 0.075\n            qn <- stats::qqnorm(plot.data$.wstdresid, ylim = ylim, \n                plot.it = FALSE)\n            plot.data$.qqx <- qn$x\n            plot.data$.qqy <- qn$y\n        }\n    }\n    label.fitted <- ifelse(is_glm, \"Predicted values\", \"Fitted values\")\n    label.y23 <- ifelse(is_glm, \"Std. deviance resid.\", \"Standardized residuals\")\n    if (is.logical(shape) && !shape) {\n        if (missing(label)) {\n            label <- TRUE\n        }\n        if (missing(label.n)) {\n            label.n <- nrow(plot.data)\n        }\n    }\n    plot.data <- flatten(plot.data)\n    if (label.n > 0L) {\n        if (show[1L]) {\n            r.data <- dplyr::arrange(plot.data, dplyr::desc(abs(.resid)))\n            r.data <- utils::head(r.data, label.n)\n        }\n        if (\".wresid\" %in% colnames(plot.data)) {\n            wr.data <- dplyr::arrange(plot.data, dplyr::desc(abs(.wresid)))\n            wr.data <- utils::head(wr.data, label.n)\n        }\n        if (any(show[4L:6L])) {\n            cd.data <- dplyr::arrange(plot.data, dplyr::desc(abs(.cooksd)))\n            cd.data <- utils::head(cd.data, label.n)\n        }\n    }\n    .smooth <- function(x, y) {\n        stats::lowess(x, y, f = 2/3, iter = 3)\n    }\n    .decorate.label <- function(p, data) {\n        if (label & label.n > 0) {\n            p <- plot_label(p = p, data = data, label = label, \n                label.label = label.label, label.colour = label.colour, \n                label.alpha = label.alpha, label.size = label.size, \n                label.angle = label.angle, label.family = label.family, \n                label.fontface = label.fontface, label.lineheight = label.lineheight, \n                label.hjust = label.hjust, label.vjust = label.vjust, \n                label.repel = label.repel)\n        }\n        p\n    }\n    .decorate.plot <- function(p, xlab = NULL, ylab = NULL, title = NULL) {\n        p + ggplot2::xlab(xlab) + ggplot2::ylab(ylab) + ggplot2::ggtitle(title)\n    }\n    smoother_m <- ggplot2::aes_string(x = \"x\", y = \"y\")\n    if (show[1L]) {\n        t1 <- \"Residuals vs Fitted\"\n        mapping <- ggplot2::aes_string(x = \".fitted\", y = \".resid\")\n        smoother <- .smooth(plot.data$.fitted, plot.data$.resid)\n        smoother <- as.data.frame(smoother)\n        p1 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n        if (!is.logical(shape) || shape) {\n            p1 <- p1 + geom_factory(geom_point, plot.data, colour = colour, \n                size = size, linetype = linetype, alpha = alpha, \n                fill = fill, shape = shape)\n        }\n        p1 <- p1 + ggplot2::geom_line(data = smoother, mapping = smoother_m, \n            colour = smooth.colour, linetype = smooth.linetype) + \n            ggplot2::geom_hline(yintercept = 0L, linetype = ad.linetype, \n                size = ad.size, colour = ad.colour)\n        p1 <- .decorate.label(p1, r.data)\n        p1 <- .decorate.plot(p1, xlab = label.fitted, ylab = \"Residuals\", \n            title = t1)\n    }\n    if (show[2L]) {\n        t2 <- \"Normal Q-Q\"\n        qprobs <- c(0.25, 0.75)\n        qy <- stats::quantile(plot.data$.wstdresid, probs = qprobs, \n            names = FALSE, type = 7, na.rm = TRUE)\n        qx <- stats::qnorm(qprobs)\n        slope <- diff(qy)/diff(qx)\n        int <- qy[1L] - slope * qx[1L]\n        mapping <- ggplot2::aes_string(x = \".qqx\", y = \".qqy\")\n        p2 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n        if (!is.logical(shape) || shape) {\n            p2 <- p2 + geom_factory(geom_point, plot.data, colour = colour, \n                size = size, linetype = linetype, alpha = alpha, \n                fill = fill, shape = shape)\n        }\n        p2 <- p2 + ggplot2::geom_abline(intercept = int, slope = slope, \n            linetype = ad.linetype, size = ad.size, colour = ad.colour)\n        p2 <- .decorate.label(p2, wr.data)\n        p2 <- .decorate.plot(p2, xlab = \"Theoretical Quantiles\", \n            ylab = label.y23, title = t2)\n    }\n    if (show[3L]) {\n        t3 <- \"Scale-Location\"\n        mapping <- ggplot2::aes_string(x = \".fitted\", y = \"sqrt(abs(.wstdresid))\")\n        smoother <- .smooth(plot.data$.fitted, sqrt(abs(plot.data$.wstdresid)))\n        smoother <- as.data.frame(smoother)\n        p3 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n        if (!is.logical(shape) || shape) {\n            p3 <- p3 + geom_factory(geom_point, plot.data, colour = colour, \n                size = size, linetype = linetype, alpha = alpha, \n                fill = fill, shape = shape)\n        }\n        p3 <- p3 + ggplot2::geom_line(data = smoother, mapping = smoother_m, \n            colour = smooth.colour, linetype = smooth.linetype)\n        p3 <- .decorate.label(p3, wr.data)\n        label.y3 <- ifelse(is_glm, expression(sqrt(abs(`Std. deviance resid.`))), \n            expression(sqrt(abs(`Standardized residuals`))))\n        p3 <- .decorate.plot(p3, xlab = label.fitted, ylab = label.y3, \n            title = t3)\n    }\n    if (show[4L]) {\n        t4 <- \"Cook's distance\"\n        mapping <- ggplot2::aes_string(x = \".index\", y = \".cooksd\", \n            ymin = 0, ymax = \".cooksd\")\n        p4 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n        if (!is.logical(shape) || shape) {\n            p4 <- p4 + geom_factory(geom_linerange, plot.data, \n                colour = colour, size = size, linetype = linetype, \n                alpha = alpha, fill = fill, shape = shape)\n        }\n        p4 <- .decorate.label(p4, cd.data)\n        p4 <- .decorate.plot(p4, xlab = \"Obs. Number\", ylab = \"Cook's distance\", \n            title = t4)\n    }\n    if (show[5L]) {\n        if (is_const_lev & ncol(fs) > 0) {\n            t5 <- \"Constant Leverage:\\nResiduals vs Factor Levels\"\n            mapping <- ggplot2::aes_string(x = \".nf\", y = \".stdresid\")\n            p5 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n            if (!is.logical(shape) || shape) {\n                p5 <- p5 + geom_factory(geom_point, plot.data, \n                  colour = colour, size = size, linetype = linetype, \n                  alpha = alpha, fill = fill, shape = shape)\n            }\n            p5 <- p5 + ggplot2::geom_hline(yintercept = 0L, linetype = ad.linetype, \n                size = ad.size, colour = ad.colour) + ggplot2::expand_limits(x = 0)\n            p5 <- .decorate.label(p5, cd.data)\n            label.y5 <- ifelse(is_glm, \"Std. Pearson resid.\", \n                \"Standardized Residuals\")\n            p5 <- .decorate.plot(p5, xlab = \"Factor Level Combination\", \n                ylab = label.y5, title = t5)\n        }\n        else {\n            t5 <- \"Residuals vs Leverage\"\n            mapping <- ggplot2::aes_string(x = \".hat\", y = \".stdresid\")\n            smoother <- .smooth(plot.data$.hat, plot.data$.stdresid)\n            smoother <- as.data.frame(smoother)\n            p5 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n            if (!is.logical(shape) || shape) {\n                p5 <- p5 + geom_factory(geom_point, plot.data, \n                  colour = colour, size = size, linetype = linetype, \n                  alpha = alpha, fill = fill, shape = shape)\n            }\n            p5 <- p5 + ggplot2::geom_line(data = smoother, mapping = smoother_m, \n                colour = smooth.colour, linetype = smooth.linetype) + \n                ggplot2::geom_hline(yintercept = 0L, linetype = ad.linetype, \n                  size = ad.size, colour = ad.colour) + ggplot2::expand_limits(x = 0)\n            p5 <- .decorate.label(p5, cd.data)\n            label.y5 <- ifelse(is_glm, \"Std. Pearson resid.\", \n                \"Standardized Residuals\")\n            p5 <- .decorate.plot(p5, xlab = \"Leverage\", ylab = label.y5, \n                title = t5)\n        }\n    }\n    if (show[6L]) {\n        t6 <- \"Cook's dist vs Leverage\"\n        mapping <- ggplot2::aes_string(x = \".hat\", y = \".cooksd\")\n        smoother <- .smooth(plot.data$.hat, plot.data$.cooksd)\n        smoother <- as.data.frame(smoother)\n        p6 <- ggplot2::ggplot(data = plot.data, mapping = mapping)\n        if (!is.logical(shape) || shape) {\n            p6 <- p6 + geom_factory(geom_point, plot.data, colour = colour, \n                size = size, linetype = linetype, alpha = alpha, \n                fill = fill, shape = shape)\n        }\n        p6 <- p6 + ggplot2::geom_line(data = smoother, mapping = smoother_m, \n            colour = smooth.colour, linetype = smooth.linetype) + \n            ggplot2::expand_limits(x = 0, y = 0)\n        p6 <- .decorate.label(p6, cd.data)\n        p6 <- .decorate.plot(p6, xlab = \"Leverage\", ylab = \"Cook's distance\", \n            title = t6)\n        g <- dropInf(hii/(1 - hii), hii)\n        p <- length(stats::coef(object))\n        bval <- pretty(sqrt(p * plot.data$.cooksd/g), 5)\n        for (i in seq_along(bval)) {\n            bi2 <- bval[i]^2\n            p6 <- p6 + ggplot2::geom_abline(intercept = 0, slope = bi2, \n                linetype = ad.linetype, size = ad.size, colour = ad.colour)\n        }\n    }\n    if (is.null(ncol)) {\n        ncol <- 0\n    }\n    if (is.null(nrow)) {\n        nrow <- 0\n    }\n    plot.list <- list(p1, p2, p3, p4, p5, p6)[which]\n    new(\"ggmultiplot\", plots = plot.list, nrow = nrow, ncol = ncol)\n}\n<bytecode: 0x571f9ac8e0d0>\n<environment: namespace:ggfortify>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_get_method(augment.lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, data = model.frame(x), newdata = NULL, se_fit = FALSE, \n    interval = c(\"none\", \"confidence\", \"prediction\"), conf.level = 0.95, \n    ...) \n{\n    warn_on_subclass(x, \"augment\")\n    check_ellipses(\"level\", \"augment\", \"lm\", ...)\n    interval <- match.arg(interval)\n    df <- augment_newdata(x, data, newdata, se_fit, interval, \n        level = conf.level)\n    if (is.null(newdata)) {\n        tryCatch({\n            infl <- influence(x, do.coef = FALSE)\n            df <- add_hat_sigma_cols(df, x, infl)\n        }, error = data_error)\n    }\n    df\n}\n<bytecode: 0x571f9a6e8fc8>\n<environment: namespace:broom>\n```\n\n\n:::\n:::\n\n\n\n \n::: \n:::\n\n::: {.callout-note title='Question'} \n \n \n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_methods_class(\"prcomp\") |>\n  gt::gt() |>\n  gt::tab_header(\"Generics of class prcomp\")\n```\n\n::: {.cell-output-display}\n\\begingroup\n\\fontsize{12.0pt}{14.4pt}\\selectfont\n\\begin{longtable}{llcl}\n\\caption*{\n{\\large Generics of class prcomp}\n} \\\\ \n\\toprule\ngeneric & class & visible & source \\\\ \n\\midrule\\addlinespace[2.5pt]\naugment & prcomp & FALSE & registered S3method \\\\ \nautoplot & prcomp & FALSE & registered S3method \\\\ \nbiplot & prcomp & FALSE & registered S3method \\\\ \nfortify & prcomp & FALSE & registered S3method \\\\ \nplot & prcomp & FALSE & registered S3method \\\\ \npredict & prcomp & FALSE & registered S3method \\\\ \nprint & prcomp & FALSE & registered S3method \\\\ \nsummary & prcomp & FALSE & registered S3method \\\\ \ntidy & prcomp & FALSE & registered S3method \\\\ \n\\bottomrule\n\\end{longtable}\n\\endgroup\n\n:::\n:::\n\n\n\n \n::: \n \n:::\n\n::: {.callout-note title='Question'} \n \n \n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_dispatch(autoplot(lm0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=> autoplot.lm\n * autoplot.default\n```\n\n\n:::\n:::\n\n\n\n \n::: \n\n:::\n\n::: {.callout-note title='Question'} \n \n \n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(UCBAdmissions)\nclass(UCBAdmissions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"table\"\n```\n\n\n:::\n\n```{.r .cell-code}\notype(UCBAdmissions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"S3\"\n```\n\n\n:::\n:::\n\n\n\n\n \n::: \n:::\n\n::: {.callout-note title='Question'} \n \n \n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::s3_class(UCBAdmissions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"table\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# sloop::s3_get_method(autoplot.table)\n# sloop::s3_get_method(augment.table)\n```\n:::\n\n\n\n::: \n:::\n\n\n- [OO in Advanced R Programming 1st Edition](http://adv-r.had.co.nz/OO-essentials.html)\n- [S3 classes  Advanced R 2nd Edition](https://adv-r.hadley.nz/s3.html)\n\n\n\n\n\n\n\n## Programming with `dplyr` and `ggplot2`\n\nWe first aim at programming a function that takes as input a dataframe `df`, a column name `col`, and that, depending on the type of the column denoted by `col`, plots a histogram (for numerical column), a barplot (for factors), or raise an error of the column is neither categorical, nor numerical.\n\nThe function should return a ggplot object.\n\nHere is a first attempt. \n\nLet us first build a toy tibble. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble( \n  col_num = rnorm(100), \n  col_fac = as_factor(sample(letters, 100, replace = T)), \n  col_ts = Sys.time() + duration(sample(1:20, 100, replace=T),units=\"days\")\n) \n\ntb |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n  col_num col_fac col_ts             \n    <dbl> <fct>   <dttm>             \n1  0.139  d       2025-04-02 16:52:06\n2  1.65   v       2025-04-07 16:52:06\n3 -0.715  k       2025-04-05 16:52:06\n4 -2.02   q       2025-04-10 16:52:06\n5 -0.385  o       2025-04-03 16:52:06\n6  0.0715 g       2025-03-24 15:52:06\n```\n\n\n:::\n:::\n\n\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg_obj <-  function(df, col){\n  \n  vct <- df[[col]]  # <1>\n  tp <- class(vct)\n\n  if (tp != \"numeric\" & tp !=\"factor\") {\n    stop(paste0(col, \" is of wrong type!\"))\n  }\n\n  p <- ggplot(df) + \n    aes(x=.data[[col]])  # <2>\n\n  if (tp==\"numeric\") {\n    p <- p + geom_histogram()\n  } else {\n    p <- p + geom_bar()\n  }\n\n  p  \n}\n```\n:::\n\n\n\n1. List component is accessed by name. `col` is a string. \n2. `.data` is a pronoun for the dataframe component of the `ggplot` object\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  gg_obj(tb, \"col_num\") +\n    labs(\n      title= \"Histogram\", \n      subtitle= \"Numerical column\")\n) + (\n  gg_obj(tb, \"col_fac\") +\n    labs(\n      title= \"Barplot\",\n      subtitle= \"Factor column\"\n    )\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-progr_files/figure-pdf/unnamed-chunk-16-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\n- Pass more optional arguments to `geom_...` (use ellipsis `...`)\n- Avoid quoting the column name\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.content-visible when-profile='solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg_obj_2 <-  function(df, col, ...){\n  params <- list(...)\n  vct <- pull(df, {{col}})\n  tp <- class(vct)[1]\n\n  if (tp != \"numeric\" & tp !=\"factor\") {\n    stop(\"column is of wrong type!\")\n    return\n  }\n\n  p <- ggplot(df) + \n    aes(x={{col}})  # <1>\n\n  if (tp==\"numeric\") {\n    p <- p + geom_histogram(...) # <2>\n  } else {\n    p <- p + geom_bar(...)\n  }\n\n  p  \n}\n```\n:::\n\n\n\n1. standard technique for programming with tidy-evaluation: *embracing*.\n2. using the ellipsis \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  gg_obj(tb, \"col_num\") +\n    labs(\n      title= \"Histogram\", \n      subtitle= \"Numerical column\")\n) +\n(\n  gg_obj_2(tb, col_num, fill=\"red\") +\n    labs(\n      title= \"Histogram, tuning color\", \n      subtitle= \"Numerical column\")\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-progr_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n \n::: \n:::\n\n\n::: {.callout-note title=\"Question\"}\n\n\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nHow could you add a geom_point() layer to each element of the following list?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots <- list(\n  ggplot(mpg, aes(displ, hwy)),\n  ggplot(diamonds, aes(carat, price)),\n  ggplot(faithfuld, aes(waiting, eruptions, size = density))\n)\n```\n:::\n\n\n\n\nFrom [R Advanced Programming](https://ggplot2-book.org/programming#exercises-3)\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title='Solution'} \n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplots |> \n  map(\\(x) x + geom_point()) |>\n  patchwork::wrap_plots()\n```\n\n::: {.cell-output-display}\n![](lab-progr_files/figure-pdf/unnamed-chunk-20-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n::: \n:::\n\n## Inside `lm()`\n\n::: {.callout-note title=\"Question\"}\n\nIn classes like `lm`, `prcomp`, ... we have a member called `call`. What does it represent? How is it constructed? \n\n{{< fa hand-point-right >}} First, read the code of `lm`.\n\n:::\n\n\n```{.r}\n> lm \nfunction (formula, data, subset, weights, na.action, method = \"qr\", \n    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n    contrasts = NULL, offset, ...) \n{\n    ret.x <- x\n    ret.y <- y\n    cl <- match.call()\n    mf <- match.call(expand.dots = FALSE)\n    m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \n        \"offset\"), names(mf), 0L)\n    mf <- mf[c(1L, m)]\n    mf$drop.unused.levels <- TRUE\n    mf[[1L]] <- quote(stats::model.frame)\n    mf <- eval(mf, parent.frame())\n    if (method == \"model.frame\") \n        return(mf)\n    else if (method != \"qr\") \n        warning(gettextf(\"method = '%s' is not supported. Using 'qr'\", \n            method), domain = NA)\n    mt <- attr(mf, \"terms\")\n    y <- model.response(mf, \"numeric\")\n    w <- as.vector(model.weights(mf))\n    if (!is.null(w) && !is.numeric(w)) \n        stop(\"'weights' must be a numeric vector\")\n    offset <- model.offset(mf)\n    mlm <- is.matrix(y)\n    ny <- if (mlm) \n        nrow(y)\n    else length(y)\n    if (!is.null(offset)) {\n        if (!mlm) \n            offset <- as.vector(offset)\n        if (NROW(offset) != ny) \n            stop(gettextf(\"number of offsets is %d, should equal %d (number of observations)\", \n                NROW(offset), ny), domain = NA)\n    }\n    if (is.empty.model(mt)) {\n        x <- NULL\n        z <- list(coefficients = if (mlm) matrix(NA_real_, 0, \n            ncol(y)) else numeric(), \n                  residuals = y, \n                  fitted.values = 0 * y, \n                  weights = w, \n                  rank = 0L, \n                  df.residual = if (!is.null(w)) sum(w != 0) else ny\n              )\n        if (!is.null(offset)) {\n            z$fitted.values <- offset\n            z$residuals <- y - offset\n        }\n    }\n    else {\n        x <- model.matrix(mt, mf, contrasts)\n        z <- if (is.null(w)) \n            lm.fit(x, y, offset = offset, singular.ok = singular.ok, \n                ...)\n        else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, \n            ...)\n    }\n    class(z) <- c(if (mlm) \"mlm\", \"lm\")\n    z$na.action <- attr(mf, \"na.action\")\n    z$offset <- offset\n    z$contrasts <- attr(x, \"contrasts\")\n    z$xlevels <- .getXlevels(mt, mf)\n    z$call <- cl\n    z$terms <- mt\n    if (model) \n        z$model <- mf\n    if (ret.x) \n        z$x <- x\n    if (ret.y) \n        z$y <- y\n    if (!qr) \n        z$qr <- NULL\n    z\n}\n<bytecode: 0x55564224e930>\n<environment: namespace:stats>\n```\n\n::: {.callout-note title='Question'} \n \nHave a look at function `match.call()`\n\n\n \n:::\n\n::::: {.content-visible when-profile=\"solution\"}  \n\n::: {.content-visible when-profile='solution'} \n \n \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- match.call(get, call(\"get\", \"abc\", i = FALSE, p = 3))\n\nis_expression(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_call(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::ast(match.call(get, call(\"get\", \"abc\", i = FALSE, p = 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n‚ñà‚îÄmatch.call \n‚îú‚îÄget \n‚îî‚îÄ‚ñà‚îÄcall \n  ‚îú‚îÄ\"get\" \n  ‚îú‚îÄ\"abc\" \n  ‚îú‚îÄi = FALSE \n  ‚îî‚îÄp = 3 \n```\n\n\n:::\n:::\n\n\n\n\nLet us explore the next toy example. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun <- function(x, lower = 0, upper = 1) {\n  structure((x - lower) / (upper - lower), CALL = match.call())\n}\n\n\nw <- fun(4 * atan(1), u = pi)\n\ntype_of(w)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `type_of()` is deprecated as of rlang 0.4.0.\nPlease use `typeof()` or your own version instead.\nThis warning is displayed once every 8 hours.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\nattr(,\"CALL\")\nfun(x = 4 * atan(1), upper = pi)\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num 1\n - attr(*, \"CALL\")= language fun(x = 4 * atan(1), upper = pi)\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- attr(w, 'CALL')\n\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"language\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis_call(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\neval(x)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\nattr(,\"CALL\")\nfun(x = 4 * atan(1), upper = pi)\n```\n\n\n:::\n\n```{.r .cell-code}\n# try also eval_tidy(), eval_bare\n```\n:::\n\n\n\n\n:::\n\n:::::\n\n## Data masking and environments\n\n::: {.callout-note title=\"Question\"}\n\n\n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}  \n\n::: {.callout-tip title='Solution'} \n \n \n:::\n\n:::::\n\n\n## Tidy evaluation\n\n::: {.callout-note title=\"Question\"}\n\nWhat is *quasi-quotation*?\n\nKeep the `rlang` cheatsheet around. \n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}  \n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n:::::\n\n::: {.callout-note title=\"Question\"}\n\nExplain the difference between an *expression* and a *quosure*\n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}  \n\n\n\n:::::\n\n\n::: {.callout-note title=\"Question\"}\n\n\n\n:::\n\n## References \n\n[Programming with `ggplot`](https://ggplot2-book.org/programming)\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\n\\usepackage{caption}\n\\usepackage{longtable}\n\\usepackage{colortbl}\n\\usepackage{array}\n\\usepackage{anyfontsize}\n\\usepackage{multirow}\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}