{
  "hash": "38e78a7cffdc41782cbaa469de9d588c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: \"2025-03-13 13:30:32.690807\"\ntitle: \"LAB: Principal Component Analysis\"\n\n\nexecute:\n  echo: true\n  eval: true\n  collapse: true\n\nformat:\n  html:\n    output-file: lab-pca.html\n  pdf:\n    output-file: lab-pca.pdf\n\n\nengine: knitr\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# We will use the following packages. \n# If needed, install them : pak::pkg_install(). \nstopifnot(\n  require(\"magrittr\"),\n  require(\"lobstr\"),\n  require(\"ggforce\"),\n  require(\"gt\"),\n  require(\"glue\"),\n  require(\"skimr\"),\n  require(\"corrr\"),\n  require(\"patchwork\"), \n  require(\"tidyverse\")\n  # require(\"autoplotly\")\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nold_theme <- theme_set(theme_minimal())\n\noptions(ggplot2.discrete.colour=\"viridis\")\noptions(ggplot2.discrete.fill=\"viridis\")\noptions(ggplot2.continuous.fill=\"viridis\")\noptions(ggplot2.continuous.colour=\"viridis\")\n```\n:::\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| Année {{< var year >}}     |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n## Swiss fertility data\n\n\nDataset  `swiss`  from `datasets::swiss` connect [fertility](https://en.wikipedia.org/wiki/Total_fertility_rate) and\nsocial, economic data within 47 French-speaking districts in [Switzerland](https://en.wikipedia.org/wiki/Switzerland).\n\n-   `Fertility` : fertility index\n-   `Agriculture` : jobs in agricultural sector\n-   `Examination` : literacy index (military examination)\n-   `Education` : proportion of people with successful secondary education\n-   `Catholic` : proportion of Catholics\n-   `Infant.Mortality` : mortality quotient at age 0\n\nFertility index (`Fertility`) is considered as the *response variable*\n\nThe social and economic variables are *covariates* (*explanatory* variables).\n\nSee [European Fertility Project](https://pop.princeton.edu/european-fertility-project#:-:text=switzerland) for more on this dataset.\n\n![](/images/Karte_Bezirke_der_Schweiz_farbig_2018.png)\n\n\nPCA (Principal Component Analysis) is concerned with covariates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"swiss\")\n\nswiss %>% \n  glimpse(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 47\nColumns: 6\n$ Fertility        <dbl> 80.2, 83.1, 92.5, 85.8,~\n$ Agriculture      <dbl> 17.0, 45.1, 39.7, 36.5,~\n$ Examination      <int> 15, 6, 5, 12, 17, 9, 16~\n$ Education        <int> 12, 9, 5, 7, 15, 7, 7, ~\n$ Catholic         <dbl> 9.96, 84.84, 93.40, 33.~\n$ Infant.Mortality <dbl> 22.2, 22.2, 20.2, 20.3,~\n```\n\n\n:::\n:::\n\n\n\n\nHave a look at the documentation of the dataset\n\n\n\n\n\n\n\n\n## Describe the dataset\n\n::: {.callout-note title=\"Question\"}\n\nCompute summary for each variable\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-tip title=\"solution\"} \n\nIt is enough to call `summary()` on each column of `swiss`. \nThis can be done in a functional programming style using package `purrr`. \nThe collections of summaries can be rearranged so as to build a dataframe that is \nfit for reporting.  \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntt <- map_dfr(swiss, summary, .id = \"var\")  \n```\n:::\n\n\n\n\n::: {.content-visible when-format=\"html\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntt |> \n  gt::gt() |> \n  gt::fmt_number(decimals=1)\n```\n:::\n\n\n\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntt %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|var              |  Min.| 1st Qu.| Median|     Mean| 3rd Qu.|  Max.|\n|:----------------|-----:|-------:|------:|--------:|-------:|-----:|\n|Fertility        | 35.00|  64.700|  70.40| 70.14255|  78.450|  92.5|\n|Agriculture      |  1.20|  35.900|  54.10| 50.65957|  67.650|  89.7|\n|Examination      |  3.00|  12.000|  16.00| 16.48936|  22.000|  37.0|\n|Education        |  1.00|   6.000|   8.00| 10.97872|  12.000|  53.0|\n|Catholic         |  2.15|   5.195|  15.14| 41.14383|  93.125| 100.0|\n|Infant.Mortality | 10.80|  18.150|  20.00| 19.94255|  21.700|  26.6|\n\n\n:::\n:::\n\n\n\n:::\n\nFunction `skim` from `skimr`  delivers all univariate summaries in suitable form. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- swiss %>% \n  select(-Fertility) %>% \n  skim()  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfoobar <- foo %>%  \n  filter(skim_type==\"numeric\") %>% \n  rename(variable=skim_variable)  %>% \n    mutate(across(where(is.numeric), ~ round(.x, digits=1))) \n```\n:::\n\n\n\n\n::: {.content-visible when-format=\"html\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoobar %>% \n  gt::gt() \n```\n:::\n\n\n\n\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoobar %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|skim_type |variable         | n_missing| complete_rate| numeric.mean| numeric.sd| numeric.p0| numeric.p25| numeric.p50| numeric.p75| numeric.p100|numeric.hist |\n|:---------|:----------------|---------:|-------------:|------------:|----------:|----------:|-----------:|-----------:|-----------:|------------:|:------------|\n|numeric   |Agriculture      |         0|             1|         50.7|       22.7|        1.2|        35.9|        54.1|        67.7|         89.7|▃▃▆▇▅        |\n|numeric   |Examination      |         0|             1|         16.5|        8.0|        3.0|        12.0|        16.0|        22.0|         37.0|▅▇▆▂▂        |\n|numeric   |Education        |         0|             1|         11.0|        9.6|        1.0|         6.0|         8.0|        12.0|         53.0|▇▃▁▁▁        |\n|numeric   |Catholic         |         0|             1|         41.1|       41.7|        2.1|         5.2|        15.1|        93.1|        100.0|▇▁▁▁▅        |\n|numeric   |Infant.Mortality |         0|             1|         19.9|        2.9|       10.8|        18.1|        20.0|        21.7|         26.6|▁▂▇▆▂        |\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nDisplay graphic summary for each variable.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\nWe have to pick some graphical summary of the data. Boxplots and violine plots could be used if we look for concision.\n\nWe use histograms to get more details about each column. \n\nNot that covariates have different meanings:  `Agriculture`, `Catholic`, `Examination`, and `Education` are percentages with values between $0$ and $100$.  \n\nWe have no details about the standardized fertility index `Fertility`\n\n`Infant.Mortality` is also a rate:  \n\n> Infant mortality is the death of an infant before his or her first birthday. The infant mortality rate is the number of infant deaths for every 1,000 live births. In addition to giving us key information about maternal and infant health, the infant mortality rate is an important marker of the overall health of a society.\n\nsee [Center for Desease Control](https://www.cdc.gov/reproductivehealth/maternalinfanthealth/infantmortality.htm)\n\nWe reuse the function we have already developped during previous sessions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_biotifoul(swiss, .f = is.numeric)\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/make_biotiful-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nHistograms reveal that our covariates have very different distributions. \n\nReligious affiliation (`Catholic`) tells us that there two types of districts, which is  reminiscent of the old principle *Cujus regio, ejus religio* , see [Old Swiss Confederacy](https://en.wikipedia.org/wiki/Old_Swiss_Confederacy). \n\n`Agriculture` shows that in most districts, agriculture was still a very important activity.\n\n`Education` reveals that in all but a few districts, most children did not receive secondary education. `Examination` shows that some districts lag behind the bulk of districts. Even less exhibit a superior performance.\n\nThe two demographic variables `Fertility`  and `Infant.Mortality` look roughly unimodal with a few extreme districts.\n\n\n\n:::::\n\n:::\n\n## Investigate pairwise correlations\n\n::: {.callout-note title=\"Question\"}\n\n- Compute, display and comment the sample correlation matrix\n- Display jointplots for each pair of variables\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\nPackage `corrr`, functions `correlate` and `rplot` provide a convenient tool.\n\nNote that `corrr::rplot()` creates a graphical object of class `ggplot`.\nWe can endow it with more layers.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nswiss |> \n    corrr::correlate(use=\"pairwise.complete.obs\",method=\"pearson\", quiet=T) |> \n  corrr::shave() |> \n  corrr::rplot() + \n  labs(title=\"Correlation plot for Swiss Fertility data\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/corplot_swiss-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nThe high positive linear correlation between `Education` and `Examination` is moderately surprising. The negative correlation between the proportion of people involved in `Agriculture` and `Education` and `Examination`is also not too surprising. Secondary schooling required pupils from rural areas to move to  cities. \n\nA more intriguing observation concerns the pairs `Catholic` and `Examination` (negative correlation) and `Catholic`  and `Education` (little correlation). \n\nThe response variable `Fertility` looks negatively correlated with `Examination` an `Education`. These correlations are worth being further explored. In Demography, the decline of Fertility is often associated with the the rise of women education. Note that `Examination` is about males, and that `Education` does not give details about the way women complete primary education. \n\n\n\n\n:::::\n\n\n\n:::\n\n\n## Singular Value Decomposition (SVD) \n\n\n\n::: {.callout-note title=\"Question\"}\n\n- Project the `swiss` dataset  on the covariates (all columns but `Fertility`)\n- Center the projected data using matrix manipulation\n- Center the projected data using `dplyr` verbs \n- Compare the results with the output of `scale()` with various optional arguments\n- Call the centered matrix `Y`\n   \n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\nHand-made centering of the dataframe emphasises the fact that centering is  a linear  operation.\nAs a matter of fact, it consists in projecting the data frame on the linear space orthogonal to the constant vector.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- select(swiss, -Fertility) |> \n    as.matrix()\n\nn <- nrow(X)\nones <-  matrix(1, nrow = n, ncol=1) \n\nY <-  X - (1/n)* (ones  %*%  t(ones) %*% X) \n```\n:::\n\n\n\n\nWe can also perform centering using `dplyr` verbs. This can be viewed as computing a window function over a  trivial partition. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nswiss |> \n  select(-Fertility) |>\n  mutate(across(everything(), \\(x) x-mean(x)))  \n```\n:::\n\n\n\n\n:::::\n\n::::: {.callout-tip}\n\nAnyway, function `scale(X, scale=F)` from base `R` does the job.\n\n:::::\n\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nCheck that the ouput of `svd(Y)` actually defines a Singular Value Decomposition.\n\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\n`svd(Y)` is a list with $3$ elements (`u,d,v`).\n\n$$Y = U \\times D \\times V^\\top$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsvd_Y <-  svd(Y)\n\nsvd_Y %$%   # <1> \n  (Y - u %*% diag(d) %*% t(v)) %>% \n  norm(type = \"F\")   # <2> \n\nnorm( \n  diag(1, ncol(Y)) - \n  (svd_Y %$% (t(v) %*% v)), \n  'F'\n)  # <3>. \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.04354e-13\n[1] 1.137847e-15\n```\n\n\n:::\n:::\n\n\n\n1. Exposing pipe from `magrittr`\n2. Checking the factorization\n3. Checking that colomns of `v` form an orthonormal family \n\n:::::\n\n::::: {.callout-tip}\n\nNote that we used the exposing pipe `%$%` from `magrittr` to unpack `svd_Y` which is a list with class `svd`  and members named `u`, `d` and `v`. \n\nWe could have used `with(,)` from base `R`. \n\n\n:::::\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nRelate the SVD of $Y$ and the eigen decomposition of $Y^\\top \\times Y$ \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"solution\"} \n\nThe matrix $1/n Y^\\top \\times Y$ is the covariance matrix\nof the covariates. \n\nThe spectral decomposition of the symmetric Semi Definite Positive (SDP) matrix  $1/n Y^\\top \\times Y$ is related with the \nSVD factorization of $Y$. \n\nThe spectral/eigen decomposition of $Y^\\top \\times Y$ can be obtained using `eigen()`. \n\nThe eigenspaces of $Y^\\top \\times Y$ are the right eigenspaces  of $Y$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(t(eigen(t(Y) %*% Y )$vectors) %*% svd_Y$v ) %>% \n  round(digits=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0   -1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n\n\n:::\n:::\n\n\n\n\nThe eigenvalues of $Y^\\top \\times Y$ are the squared singular values of $Y$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigen(t(Y) %*% Y )$values - (svd_Y$d)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.309672e-10 -1.455192e-11  8.640200e-12  8.526513e-12 -3.410605e-13\n```\n\n\n:::\n:::\n\n\n\n:::::\n\n\n::: {.callout-caution}\n\nHere, the eigenvectors of $Y^\\top \\times Y$ coincide with the right singular vectors of $Y$ corresponding to non-zero singular values. Up to sign changes, it is always true when the  non-zero singular values are pairwise distinct. \n\n:::\n\n:::\n\n\n\n## Perform PCA on covariates\n\n::: {.callout-note title=\"Question\"}\n\nPairwise analysis did not provide us with a clear and simple picture of the French-speaking districts. \n\nPCA (Principal Component Analysis) aims at exploring the variations of multivariate datasets around their mean\n(center of inertia). In the sequel, we will perform PCA on the matrix of centered covariates, with and without standardizing the centered columns.  \n\nBase `R` offers `prcomp()`. Call `prcomp()` on the centered covariates\n\nNote that `R` also offers `princomp`\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\nWe first call `prcomp()` with the default arguments for centering and scaling, that is, we center columns and do not attempt to standardize columns. Name the output `pco`.  \n\nWhat is the result made of?\n\n\n::::: {.callout-tip title=\"solution\"} \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco <- swiss |> \n  select(-Fertility) |> \n  scale(scale = F) |> \n  prcomp(scale. = F)\n```\n:::\n\n\n\n\n`pco` is a list with 5 members. It as a class attribute `prcomp`. It is an object of class `prcomp` (function `prcomp()` acts as a constructor for class `pco` just as `lm()` acts as  a constructor for class `lm`). [Class `pco` is an `S3` class](https://adv-r.hadley.nz/s3.html)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::is_list(pco)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(pco)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"sdev\"     \"rotation\" \"center\"   \"scale\"    \"x\"       \n\n$class\n[1] \"prcomp\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::s3_class(pco)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"prcomp\"\n```\n\n\n:::\n:::\n\n\n\n:::::\n\n:::\n\n\n\n\n::: {.callout-note title=\"Question\"}\n\nCheck that `prcomp()` is indeed a wrapper for `svd()`.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"solution\"} \n\n\nWe first check that the matrix can be recovered from the product of the components of the `prcomp` object. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(Y - pco$x %*% t(pco$rotation )) %>% \n  round(digits = 2)  %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             Agriculture Examination Education Catholic Infant.Mortality\nCourtelary             0           0         0        0                0\nDelemont               0           0         0        0                0\nFranches-Mnt           0           0         0        0                0\nMoutier                0           0         0        0                0\nNeuveville             0           0         0        0                0\nPorrentruy             0           0         0        0                0\n```\n\n\n:::\n:::\n\n\n\n\nWe now check that the `rotation` component is indeed made of the right singular vectors (the $V$ factor)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(svd_Y$v %*% t(pco$rotation )) %>% \n  round(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Agriculture Examination Education Catholic Infant.Mortality\n[1,]           1           0         0        0                0\n[2,]           0           1         0        0                0\n[3,]           0           0         1        0                0\n[4,]           0           0         0        1                0\n[5,]           0           0         0        0                1\n```\n\n\n:::\n:::\n\n\n\n\nThe column vectors of component $x$ are pairwise orthogonal. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(t(pco$x) %*% pco$x) %>% \n  round(2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         PC1      PC2     PC3    PC4    PC5\nPC1 86484.49     0.00    0.00   0.00   0.00\nPC2     0.00 21127.44    0.00   0.00   0.00\nPC3     0.00     0.00 2706.14   0.00   0.00\nPC4     0.00     0.00    0.00 639.22   0.00\nPC5     0.00     0.00    0.00   0.00 348.01\n```\n\n\n:::\n:::\n\n\n\n\nThe `x` component of the  `prcomp` object is  the product of the $U$ and $D$  factors. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnorm(pco$x - svd_Y$u %*% diag(svd_Y$d),type=\"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.962527e-13\n```\n\n\n:::\n\n```{.r .cell-code}\nnorm(as.matrix(pco$rotation) -svd_Y$v, type=\"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.04934e-15\n```\n\n\n:::\n:::\n\n\n\n\nThe connection between $pco$sdev$ and $svd_Y$d$ is somewhat less transparent.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(abs(apply(pco$x, 2, sd) - pco$sdev))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.865175e-14\n```\n\n\n:::\n:::\n\n\n\n\n\nThe components of `pco$sdev` are the standard deviations of the columns of $U \\times D$.\n<!-- $$\\verb{pco$sdev}[i]^2 = \\frac{\\verb{svd_Y$d}[i]^2}{n-1}$$ -->\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco$sdev - svd_Y$d/sqrt(nrow(Y)-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -7.105427e-15  0.000000e+00  8.881784e-16 -1.332268e-15 -1.332268e-15\n```\n\n\n:::\n:::\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nCheck that rows and columns of component `rotation` of the result of `prcomp()` \nhave unit norm.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\nCheck that rows and columns of matrix `rotation`  have unit norm.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(pco$rotation, 2, \\(x) norm(x, \"2\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPC1 PC2 PC3 PC4 PC5 \n  1   1   1   1   1 \n```\n\n\n:::\n\n```{.r .cell-code}\napply(pco$rotation, 1, \\(x) norm(x, \"2\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Agriculture      Examination        Education         Catholic \n               1                1                1                1 \nInfant.Mortality \n               1 \n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nCheck Orthogonality of $V$ (component `rotation` of the `prcomp` object)\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# checking that pco$rotation is an orthogonal matrix \nt(pco$rotation) %*% pco$rotation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              PC1           PC2           PC3           PC4           PC5\nPC1  1.000000e+00 -1.003429e-16  8.239937e-18 -1.097213e-16  6.938894e-18\nPC2 -1.003429e-16  1.000000e+00  1.181780e-16  5.074066e-17  4.857226e-17\nPC3  8.239937e-18  1.181780e-16  1.000000e+00  1.717376e-16 -6.938894e-17\nPC4 -1.097213e-16  5.074066e-17  1.717376e-16  1.000000e+00 -1.804112e-16\nPC5  6.938894e-18  4.857226e-17 -6.938894e-17 -1.804112e-16  1.000000e+00\n```\n\n\n:::\n\n```{.r .cell-code}\npco$rotation %*% t(pco$rotation)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   Agriculture   Examination     Education      Catholic\nAgriculture       1.000000e+00  3.642919e-17 -1.153591e-16  1.689187e-16\nExamination       3.642919e-17  1.000000e+00 -8.630249e-17  2.244298e-17\nEducation        -1.153591e-16 -8.630249e-17  1.000000e+00 -1.127570e-16\nCatholic          1.689187e-16  2.244298e-17 -1.127570e-16  1.000000e+00\nInfant.Mortality  2.081668e-17 -1.734723e-16  8.326673e-17 -2.081668e-17\n                 Infant.Mortality\nAgriculture          2.081668e-17\nExamination         -1.734723e-16\nEducation            8.326673e-17\nCatholic            -2.081668e-17\nInfant.Mortality     1.000000e+00\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nMake a scatterplot from the first two columns of  the \n$x$ component of the `prcomp` object. \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\nObjects of class `prcomp` can be handled by generic functions like `plot()` or better `autoplot()`.\nNamely, method `prcomp` for generic S3 function `autoplot()` from `ggplot2` delivers one of classical \nSVD plots. \n\n::: {.columns}\n\n::: {.column}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- autoplot(pco) +\n  coord_fixed() +\n  theme_minimal()\n\nts <- theme_set(theme_minimal())\n\nres\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-30-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n\n::: {.column}\n\n`autoplot(pco)` is a scatterplot for the dataframe defined by matrix $U \\times D$ projected on its first \ntwo principal components (first two columns). \n\n:::\n\n::: \n\nAs `autoplot(pco)` is an instance of class  `ggplot`, it can be annotated, decorated as any other `ggplot` object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  res + aes(color=Catholic) + theme_minimal()\n) +\n(  \n  res + aes(color=Education) + theme_minimal()\n) +\n  patchwork::plot_annotation(\n    subtitle = \"Scatterplot on the first two principal components (no column scaling)\",\n    title= \"Share of catholics can almost be determined from the sign of the first PC\",\n    caption = \"Swiss  Fertility data from R datasets\"\n  ) \n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n:::::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nDefine a graphical pipeline for the *screeplot*. \n\nHint: use function `tidy()` from `broom`, to get the data in the right form from an instance of `prcomp`.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\nThe screeplot is a bar plot where each bar corresponds to a  singular value. The bar height is proportional to the square of the corresponding singular value. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_screeplot <- . %>%   # <1>\n  broom::tidy(matrix=\"pcs\") %>% { \n  ggplot(.) +\n  aes(x=PC, y=percent, label=pct_format(1.-cumulative)) +   # <3>\n  geom_text(angle=45, vjust=-1, hjust=-.1) + \n  geom_col(fill=NA, colour=\"black\") + # <2>\n  theme_minimal()\n  } \n```\n:::\n\n\n\n1. Define a pipeline for building a screeplot\n2. Mind the braces on the right side of the first pipe\n3. `1- cumulative` tell the reader about the relative Frobenious error achieved by keeping the first components of the SVD expansion. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco %>% \n  p_screeplot() +\n  ylab('Relative squared Frobenius error/Relative squared error') +\n  labs(\n    title=\"Screeplot for swiss fertility data\",\n    subtitle=\"Keeping the first two components is enough to achieve relative Froebenius relative error 3.3%\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-33-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nThe screeplot is a visualization of the Eckart-Young-Mirsky Theorem. It tells us about the relative errors \nincurent when approximating the data matrix (with centered columns) by the low rank approximations defined by the \ntruncated SVDs.\n\n\n:::::\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nDefine a function that replicates `autoplot.prcomp()`\n\nProject the dataset on the first two principal components (perform dimension reduction) and build a scatterplot. Colour the points according to the value of  original covariates.  \n\nHint: use generic function `augment` from `broom`.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <-  pco %>% # <1>\n  broom::augment(swiss) %>% \n  ggplot() +\n  aes(x=.fittedPC1, y=.fittedPC2, label=.rownames) +\n  geom_point() +\n  coord_fixed() +  # <2>  \n  ggrepel::geom_text_repel()  +\n  theme_minimal()\n\n(p + \n  aes(color=Infant.Mortality)) +\n(p + \n   aes(color=Education)) +\n(p + \n   aes(color=Examination)) +\n(p + \n   aes(color=Catholic)) +\n(p + \n   aes(color=Agriculture)) +\n(p + \n   aes(color=Fertility)) +  \nplot_layout(ncol = 2) +\nplot_annotation(title=\"Swiss data on first two PCs\" , \n                subtitle = \"centered, unscaled\")\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-34-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nApply `broom::tidy()` with optional argument `matrix=\"v\"` or `matrix=\"loadings\"` to the `prcomp` object. \n\nComment. \n\n:::\n\n::: {.callout-note}\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\nWe can extract factor $V$ from the SVD factorization \nusing generic function `tidy` from package `broom`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco %>% \n  broom::tidy(matrix=\"v\") %>% \n  sample_n(5) |>\n  gt::gt()\n```\n\n::: {.cell-output-display}\n\\begingroup\n\\fontsize{12.0pt}{14.4pt}\\selectfont\n\\begin{longtable}{lrr}\n\\toprule\ncolumn & PC & value \\\\ \n\\midrule\\addlinespace[2.5pt]\nInfant.Mortality & 5 & -0.99110977 \\\\ \nEducation & 3 & -0.80696178 \\\\ \nEducation & 1 & -0.05841770 \\\\ \nAgriculture & 4 & -0.02652821 \\\\ \nEducation & 2 & 0.31078077 \\\\ \n\\bottomrule\n\\end{longtable}\n\\endgroup\n\n:::\n:::\n\n\n\n\nThe result is a tibble in *long form*. It is worth pivoting the dataframe  into wide form.\nThis gives back the rotation matrix. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nom <- pco %>% \n  broom::tidy(matrix=\"v\") %>% \n  tidyr::pivot_wider(id_cols =column, \n              names_from = PC, \n              values_from = value) |> \n  select(-1) |>\n  as.matrix()\n\nnorm((om %*% t(om))-diag(1,5), \"F\")        \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.196585e-16\n```\n\n\n:::\n:::\n\n\n\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nBuild the third SVD plot, the so called *correlation circle*. \n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\nThe correlation circle is built from the *loadings*, that is, from the `rotation` component of the `prcomp` object.\n\nWe define a preprocessing function to  transform the rotation object into a proper `tibble` form. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprep_co_circle <- function(pco) {\n  r <- pco$rotation\n  as_tibble(r) |> \n    rename_with(.fn = \\(x) gsub('PC', '', x), .cols=everything()) |>\n    mutate(row_id=rownames(r))\n}\n```\n:::\n\n\n\n\nThe The next virtual graphical object  will be our key tool to build the correlation circle. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco_circle_ppl <- (\n    pco %>% \n    prep_co_circle() %>% \n    filter(F)\n    ) %>% \n  ggplot() +\n  aes(x=`1`, y=`2`, label=row_id) +\n  geom_segment(aes(xend=0, yend=0), arrow = grid::arrow(ends = \"first\")) +\n  ggrepel::geom_text_repel() +\n  coord_fixed() +  # <1>\n  xlim(c(-1.1, 1.1)) + ylim(c(-1.1, 1.1))  + \n  ggforce::geom_circle(aes(x0=0, y0=0, r=1), linetype=\"dashed\") +\n  theme_minimal()\n```\n:::\n\n\n\n1. important\n  \n::: {.columns}\n::: {.column}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco_circle_ppl %+% (\n  pco %>% \n  prep_co_circle()\n  )  +\n  labs(title=\"Correlation circle\", \n          subtitle = \"centered, unscaled\",\n          caption= \"Swiss Fertility dataset\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-39-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n\n\n::: {.column}\n\nThe length of each arrow is the length of the projection of the corresponding column of the data matrix\nover the plane generated by the first two rescaled left singular vectors (rescaling by the reciprocal \nof the singular values).\n\nThe first two principal componants (left singular vectors) are highly correlated with columns `Agriculture`\nand `Catholic`. \n\n:::\n:::\n\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nCompute PCA after standardizing the columns, draw the correlation circle. \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n::: {.columns}\n::: {.column}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco2 <- select(swiss, -Fertility) |> \n prcomp(scale. = T)\n\nco_circle_ppl %+% (\n  pco2 %>% \n  prep_co_circle()\n  )  +\n  labs(\n    title=\"Correlation circle\", \n    subtitle = \"centered, scaled\",\n    caption=\"Swiss fertility dataset\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-40-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n::: {.column}\n\nScaling columns seriously modify the correlation circle.\n\n:::\n:::\n\n\n:::\n:::\n\n\n\n\n\n\n## Compare standardized and non-standardized PCA\n\n::: {.callout-note title=\"Question\"}\n\nPay attention to the correlation circles.\n\n1.  How well are variables represented?\n2.  Which variables contribute to the first axis?\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco_c <- swiss %>% \n  select(-Fertility) %>% \n  prcomp()\n\npco_cs <- swiss %>% \n  select(-Fertility) %>% \n  prcomp(scale.=T, center=T)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  co_circle_ppl %+% \n  prep_co_circle(pco_c)  +\n  labs(\n    subtitle = \"centered, unscaled\"\n  ) + \n  theme_minimal()  \n) +\n(\n  co_circle_ppl %+%  \n  prep_co_circle(pco_cs) +\n  labs(\n    subtitle = \"centered, scaled\"\n  ) +\n  theme_minimal()  \n) +\n  patchwork::plot_annotation(\n        title=\"Swiss, correlation circle\"\n  )\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-42-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nExplain the contrast between the two correlation circles.\n\n:::\n\nIn the sequel we focus on standardized PCA.\n\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <-  autoplot(pco_cs, data=swiss) +\n  theme_minimal()\n\nts <- theme_set(theme_minimal())\n\n(q + \n  aes(color=Infant.Mortality)) +\n(q + \n   aes(color=Education)) +\n(q + \n   aes(color=Examination)) +\n(q + \n   aes(color=Catholic)) +\n(q + \n   aes(color=Agriculture)) +\n(q + \n   aes(color=Fertility)) +  \npatchwork::plot_layout(ncol = 2) +\npatchwork::plot_annotation(\n    title=\"Scatterplot on first two PCs\", \n    subtitle = \"centered, scaled PCA\",\n    caption = \"Swiss Fertility dataset\")\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-43-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n:::\n\n\n\n## Provide an interpretation of the first two principal axes\n\n::: {.callout-note title=\"Question\"}\n\nWhich variables contribute to the two first principal axes?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\nThis comes from the correlation circle. We rely on function `prep_co_circle` and \non the graphical pipeline `co_circle_ppl`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  co_circle_ppl %+% \n    prep_co_circle(pco_cs) +\n    ggtitle(\"Swiss, correlation circle\", \n            subtitle = \"centered, scaled\") +\n  theme_minimal()  \n)\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-44-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nAnalyze the signs of correlations between variables and axes?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nswiss |>   # ggrepel::geom_text_repel(data=df_cocirc, \n  #                          aes(x= 4* `1`,\n  #                              y= 4 * `2`, \n  #                              label=column), \n  #                          color=\"red\")\n  select(-Fertility) |> \n  corrr::correlate(use=\"pairwise.complete.obs\",method=\"pearson\", quiet=T) |> \n  corrr::shave() |> \n  corrr::rplot(print_cor = T) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-45-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n:::\n\n## Add the `Fertility` variable \n\n::: {.callout-note title=\"Question\"}\n\nPlot again the correlation circle using the same principal axes as before,\nbut add the `Fertility` variable. \n\nHow does  `Fertility` relate with covariates? with principal axes?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout-tip title=\"solution\"} \n\nWe use \n$$D^{-1} \\times U^\\top \\times X = V^\\top$$\n\nIt is enough to multipliy the data matrix by $D^{-1} \\times U^\\top$ and to \npipe the result into the coorelation circle graphical pipeline.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- t(diag(svd_Y$d^(-1)) %*% t(svd_Y$u) %*% as.matrix(scale(swiss, scale=F)))  \n \nco_circle_ppl  %+% (\n  as_tibble(foo) |>\n  rename_with(.fn = \\(x) gsub('V', '', x), .cols=everything()) |>\n  mutate(row_id=rownames(foo))\n) +\n  theme_minimal()  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\ni Using compatibility `.name_repair`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-46-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n:::::\n\n:::\n\n\n\n## Biplot \n\n::: {.callout-note title=\"Question\"}\n\nThe last svd plot (biplot) consists of overlaying the scatter plot of component `x` of the `prcomp` object\nand the correlation circle. \n\nSo the biplot is a graphical object built on two dataframes derived on  components  `x` and `rotation` of the `prcomp`\nobjects. \n\nDesign a graphical pipeline. \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npco <- swiss %>% \n  select(-Fertility) %>% \n  prcomp(scale.=T)\n\ndf_cocirc <- pco %>% \n  broom::tidy(matrix=\"v\") %>% \n  tidyr::pivot_wider(id_cols =column, \n              names_from = PC, \n              values_from = value) \n\nbroom::augment(pco, data=swiss) %>% \n  ggplot() + \n  geom_point(aes(x=.fittedPC1, \n                 y=.fittedPC2, \n                 color=Fertility, label=.rownames)) +\n  coord_fixed() + \n  ggrepel::geom_text_repel(aes(x=.fittedPC1, \n                               y=.fittedPC2,\n                               color=Infant.Mortality,\n                               label=.rownames)) + \n  geom_segment(data=df_cocirc,  \n               mapping=aes(x= 4* `1`, \n                           y= 4 * `2`, \n                           linetype=factor(column),\n                           label=column,\n                           xend=0, \n                           yend=0), \n               arrow = grid::arrow(ends = \"first\",\n                                    unit(.1, \"inches\")\n                                  )) + \n  scale_color_viridis_c() +\n  xlim(c(-5,5)) + \n  ylim(c(-5,5)) +\n  theme_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(aes(x = .fittedPC1, y = .fittedPC2, color = Fertility, :\nIgnoring unknown aesthetics: label\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_segment(data = df_cocirc, mapping = aes(x = 4 * `1`, y = 4 * :\nIgnoring unknown aesthetics: label\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: ggrepel: 37 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/unnamed-chunk-47-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n:::\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\n`autoplot.prcomp()` has optional arguments. If set to `True`, logical argument `loadings`\noverlays the scatterplot defined by the principal components with the correlation circle. \n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbip <- autoplot(pco_cs, \n         data=swiss, \n         color=\"Fertility\", \n         loadings = TRUE, \n         loadings.colour = 'blue',\n         loadings.label = TRUE) +\n  coord_fixed() +\n  labs(\n    title = \"Biplot\",\n    subtitle = \"PCA after centering and scaling\",\n    caption = \"Swiss Fertility dataset\"\n  ) +\n  theme_minimal()\n\nts <- theme_set(theme_minimal())\n\nbip\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/biplot-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbip_plotly <- autoplot(pco_cs, \n         data=rownames_to_column(swiss, var=\"district\"), \n         color=\"Fertility\", \n         text=\"district\", \n         loadings = TRUE, \n         loadings.colour = 'blue',\n         loadings.label = TRUE) + \n  aes(text=district) +\n  coord_fixed() +\n  labs(\n    title = \"Biplot\",\n    subtitle = \"PCA after centering and scaling\",\n    caption = \"Swiss Fertility dataset\"\n  ) +\n  theme_minimal()\n\nbip |> plotly::ggplotly()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/biplotly-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(\nbroom::augment(pco, data=rownames_to_column(swiss, var=\"district\")) |> \n  ggplot() + \n  geom_point(aes(x=.fittedPC1, \n                 y=.fittedPC2, \n                 color=Fertility,\n                 label=district)) +\n  coord_fixed() + \n  geom_segment(data=df_cocirc,  \n               mapping=aes(x= 4* `1`, \n                           y= 4 * `2`, \n                           linetype=factor(column),\n                           label=column,\n                           xend=0, \n                           yend=0), \n               arrow = grid::arrow(ends = \"first\",\n                                    unit(.1, \"inches\")\n                                  )) + \n  scale_color_viridis_c() +\n  xlim(c(-5,5)) + \n  ylim(c(-5,5)) +\n  labs(\n    title = \"Biplot\",\n    subtitle = \"PCA after centering and scaling\",\n    caption = \"Swiss Fertility dataset\"\n  ) +\n  theme_minimal() \n) |> plotly::ggplotly()\n```\n\n::: {.cell-output-display}\n![](lab-pca_files/figure-pdf/biplotly-home-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n:::\n\n:::\n\n \n\n::: {.content-hidden}\n\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n### kmeans\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkm.2 <- swiss %>%  \n  select(-Fertility) %>% \n  scale() %>% \n  kmeans(centers = 2)\n\nmake_df_centers <- function(object) { \n  as.data.frame(object[[\"centers\"]]) %>%\n  tibble::rownames_to_column(var=\".cluster\")\n}\n\ndf_centers.2 <- make_df_centers(km.2)\n```\n:::\n\n\n\n:::\n:::\n:::\n\n::: {.content-hidden}\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkm.2.pca <-  swiss %>%  \n  select(-Fertility) %>% \n  scale() %>% \n  prcomp() %>% \n  augment(data=swiss) %>% \n  select(starts_with(\".fittedPC\")) %>% \n  kmeans(centers=2)\n\ndf_centers.2.pca <- make_df_centers(km.2.pca)\n```\n:::\n\n\n\n\n:::\n:::\n:::\n\n::: {.content-hidden}\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbroom::augment(km.2, scale(swiss)) %>%\n  ggplot() +\n  aes(x=Education, y=Infant.Mortality, colour=.cluster) +\n  geom_point(aes()) +\n  stat_voronoi(data = df_centers.2,\n               geom=\"path\"               ) +\n  geom_point(data = df_centers.2,\n             colour = \"black\",\n             shape=\"+\",\n             size=5) +\n  coord_fixed() +\n  labs(col=\"Voronoï cells\") +\n  labs(\n    title= \"Kmeans over Swiss dataset, k=3\"\n  ) +\n  theme_minimal()\n```\n:::\n\n\n\n:::\n:::\n:::\n\n::: {.content-hidden}\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhiteside <-  MASS::whiteside\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwhiteside <- whiteside %>% \n  select(-Insul) %>% \n  scale() %>% \n  as_tibble() %>% \n  rename_with(.fn= ~ str_c( ., \"scaled\", sep=\"_\")) %>% \n  bind_cols(whiteside)\n\nkm.2 <- whiteside %>% \n  select(ends_with(\"scaled\")) %>% \n  kmeans(centers=2)\n\n\ndf_centers.2 <-  make_df_centers(km.2)\n```\n:::\n\n\n\n:::\n:::\n:::\n\n::: {.content-hidden}\n::: {.content-visible when-profile=\"solution\"} \n::: {.callout-tip title=\"solution\"} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbroom::augment(km.2, whiteside) %>%\n  ggplot() +\n  aes(x=Temp_scaled, y=Gas_scaled, colour=.cluster) +\n  geom_point(aes(shape=Insul)) +\n  stat_voronoi(data = df_centers.2,\n               geom=\"path\",\n              outline=data.frame(x=c(-3, 3, 3, -3), \n                                  y=c(-3, -3, 3, 3))\n               ) +\n  geom_point(data = df_centers.2,\n             colour = \"black\",\n             shape=\"+\",\n             size=5) +\n  coord_fixed() +\n  labs(col=\"Voronoï cells\") +\n  labs(title=\"Kmeans over whiteside dataset, k=2\")\n```\n:::\n\n\n\n:::\n:::\n:::\n\n# References \n\n\n[https://scholar.google.com/citations?user=xbCKOYMAAAAJ&hl=fr&oi=ao](https://scholar.google.com/citations?user=xbCKOYMAAAAJ&hl=fr&oi=ao)\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\n\\usepackage{caption}\n\\usepackage{longtable}\n\\usepackage{colortbl}\n\\usepackage{array}\n\\usepackage{anyfontsize}\n\\usepackage{multirow}\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}