{
  "hash": "0cb70f427574f3de636393d19bf44230",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tables manipulation II\"\ncategories: [Tables, tibbles, dplyr, SQL, Relational Algebra, nycflights13]\n\nexecute:\n  echo: true\n  eval: true\n  collapse: true\n\nformat:\n  html:\n    output-file: lab-tables.html\n  pdf:\n    output-file: lab-tables.pdf\n\n# params:\n#   truc: html\n#   year: 2024 \n#   curriculum: \"M1 MIDS/MFA\"\n#   university: \"Université Paris Cité\"\n#   homepage: \"https://stephane-v-boucheron.fr/courses/scidon\"\n#   moodle: \"https://moodle.u-paris.fr/course/view.php?id=6143\"\n  \nengine: knitr\n---\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| Année {{< var year >}}     |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n\n::: {.callout-important}\n\n### Objectives\n\n\n:::\n\n\n\n## Setup\n\nWe will use the following packages. If needed, we install them. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_theme <- theme_set(theme_minimal())\n```\n:::\n\n\n\n\nCheck [nycflights13](https://nycflights13.tidyverse.org) for any explanation concerning the tables and their columns. \n\n## Data loading \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights <- nycflights13::flights\nweather <- nycflights13::weather\nairports <- nycflights13::airports\nairlines <- nycflights13::airlines\nplanes <- nycflights13::planes\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\nflights_lite <- copy_to(con, nycflights13::flights)\nairports_lite <- copy_to(con, nycflights13::airports)\nplanes_lite <-  copy_to(con, nycflights13::planes)\nweather_lite <- copy_to(con, nycflights13::weather)\nairlines_lite <- copy_to(con, nycflights13::airlines)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |>\n  select(contains(\"delay\")) |>\n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `dep_delay`, `arr_delay`\nFROM `nycflights13::flights`\n```\n\n\n:::\n:::\n\n\n\n\n\nView data in spreadsheet style.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(flights)\n```\n:::\n\n\n\n\n\nAsk for help about table `flights`\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?flights\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nairports |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1,458\nColumns: 8\n$ faa   <chr> \"04G\", \"06A\", \"06C\", \"06N\", \"09J\", \"0A9\", \"0G6\", \"0G7\", \"0P2\", \"…\n$ name  <chr> \"Lansdowne Airport\", \"Moton Field Municipal Airport\", \"Schaumbur…\n$ lat   <dbl> 41.13047, 32.46057, 41.98934, 41.43191, 31.07447, 36.37122, 41.4…\n$ lon   <dbl> -80.61958, -85.68003, -88.10124, -74.39156, -81.42778, -82.17342…\n$ alt   <dbl> 1044, 264, 801, 523, 11, 1593, 730, 492, 1000, 108, 409, 875, 10…\n$ tz    <dbl> -5, -6, -6, -5, -5, -5, -5, -5, -5, -8, -5, -6, -5, -5, -5, -5, …\n$ dst   <chr> \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"U\", \"A\", \"A\", \"U\", \"A\",…\n$ tzone <chr> \"America/New_York\", \"America/Chicago\", \"America/Chicago\", \"Ameri…\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n## First Queries (the `dplyr` way)\n\nFind all flights that\n\n- Had an arrival delay of two or more hours\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(arr_delay >= 120) |> \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10200\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(arr_delay >= 120) |> \n  count()  |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT COUNT(*) AS `n`\nFROM (\n  SELECT `nycflights13::flights`.*\n  FROM `nycflights13::flights`\n  WHERE (`arr_delay` >= 120.0)\n) AS `q01`\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n::: {.callout-note title=\"Solution\"}\n\nWe can translate the `dplyr` pipeline into an `SQL` query.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(arr_delay >= 120) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `nycflights13::flights`.*\nFROM `nycflights13::flights`\nWHERE (`arr_delay` >= 120.0)\n```\n\n\n:::\n:::\n\n\n\n\nWe can even get some explanations\n\n```{.r}\nflights_lite |> \n  filter(arr_delay >= 120) |> \n  explain()\n```\n\n:::\n\n:::\n\n\n\n- Flew to Houston (`IAH` or `HOU`)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest %in% c(\"HOU\", \"IAH\")) |>  \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9313\n```\n\n\n:::\n\n```{.r .cell-code}\nflights |> \n  filter(dest == \"HOU\" | dest == \"IAH\") |> \n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1  9313\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(dest %in% c(\"HOU\", \"IAH\")) |>  \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `nycflights13::flights`.*\nFROM `nycflights13::flights`\nWHERE (`dest` IN ('HOU', 'IAH'))\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(dest == \"HOU\" | dest == \"IAH\") |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `nycflights13::flights`.*\nFROM `nycflights13::flights`\nWHERE (`dest` = 'HOU' OR `dest` = 'IAH')\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Were operated by United, American, or Delta\n\n::: {.callout-tip}\nPackage `stringr` could be useful.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairlines |> \n  filter(stringr::str_starts(name, \"United\") |\n        stringr::str_starts(name, \"American\") |\n        stringr::str_starts(name, \"Delta\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  carrier name                  \n  <chr>   <chr>                 \n1 AA      American Airlines Inc.\n2 DL      Delta Air Lines Inc.  \n3 UA      United Air Lines Inc. \n```\n\n\n:::\n\n```{.r .cell-code}\nairlines |> \n  filter(stringr::str_detect(name, (\"United|American|Delta\"))) |> \n  pull(carrier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"AA\" \"DL\" \"UA\"\n```\n\n\n:::\n:::\n\n\n\n\n```{.r}\n#| eval: false\nairlines_lite |> \n  filter(stringr::str_starts(name, \"United\") |\n        stringr::str_starts(name, \"American\") |\n        stringr::str_starts(name, \"Delta\")) |> \n  show_query()\n```\n\n```{.sql}\nSELECT *\nFROM `nycflights13::airlines`\nWHERE \"name\" LIKE 'United%' OR \n      \"name\" LIKE 'American%' OR \n      \"name\" LIKE 'Delta%' ;\n```\n\n[`stringr` is part of tidyverse](https://stringr.tidyverse.org)\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\nWe build on the tip above to extract the matching airlines codes. \n\nWe may proceed using a  *subquery*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(carrier %in% (\n        airlines |> \n        filter(stringr::str_detect(name, (\"United|American|Delta\"))) |> \n        pluck(\"carrier\")\n      )\n) |> \nhead(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n1  2013     1     1      517            515         2      830            819\n2  2013     1     1      533            529         4      850            830\n3  2013     1     1      542            540         2      923            850\n4  2013     1     1      554            600        -6      812            837\n5  2013     1     1      554            558        -4      740            728\n6  2013     1     1      558            600        -2      753            745\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(carrier %in% c(\"AA\", \"DL\", \"UA\")) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `nycflights13::flights`.*\nFROM `nycflights13::flights`\nWHERE (`carrier` IN ('AA', 'DL', 'UA'))\n```\n\n\n:::\n:::\n\n\n\n\n```{.sql}\nSELECT *\nFROM `nycflights13::flights`\nWHERE carrier IN (SELECT carrier \n  FROM `nycflights13::airlines`\n  WHERE \"name\" LIKE 'United%' OR \n        \"name\" LIKE 'American%' OR \n        \"name\" LIKE 'Delta%')\n) ; \n```\nWe may also rely on a `NATURAL JOIN`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairlines |> \n  filter(str_detect(name, \"United|Delta|American\")) |> \n  inner_join(flights) |> \n  head(6)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(carrier)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 20\n  carrier name       year month   day dep_time sched_dep_time dep_delay arr_time\n  <chr>   <chr>     <int> <int> <int>    <int>          <int>     <dbl>    <int>\n1 AA      American…  2013     1     1      542            540         2      923\n2 AA      American…  2013     1     1      558            600        -2      753\n3 AA      American…  2013     1     1      559            600        -1      941\n4 AA      American…  2013     1     1      606            610        -4      858\n5 AA      American…  2013     1     1      623            610        13      920\n6 AA      American…  2013     1     1      628            630        -2     1137\n# ℹ 11 more variables: sched_arr_time <int>, arr_delay <dbl>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n#  sample_n(size=6)    # random sampling \n```\n:::\n\n\n\n\n\n```{.r}\n#| eval: false\nairlines_lite |> \n  filter(stringr::str_starts(name, \"United\") |\n        stringr::str_starts(name, \"American\") |\n        stringr::str_starts(name, \"Delta\")) |> \n  inner_join(flights_lite) |> \n  show_query()\n```\n:::\n\n:::\n\n\n- Departed in summer (July, August, and September)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(month %in% c(7,8,9)) |> \n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1 86326\n```\n\n\n:::\n:::\n\n\n\n\n\nA more ambitious (and sustainable) approach relies on the date/time manipulation function from `lubridate`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(lubridate::month(time_hour) %in% 7:9) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n1  2013     7     1        1           2029       212      236           2359\n2  2013     7     1        2           2359         3      344            344\n3  2013     7     1       29           2245       104      151              1\n4  2013     7     1       43           2130       193      322             14\n5  2013     7     1       44           2150       174      300            100\n6  2013     7     1       46           2051       235      304           2358\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nor even \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_locale <- 'en_US.UTF-8'\n\nflights |> \n  filter(lubridate::month(time_hour, label=T, abbr=F, \n                          locale=my_locale) %in% \n                    c('juillet', 'August', 'September')) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n1  2013     8     1       12           2130       162      257             14\n2  2013     8     1       12           2359        13      349            350\n3  2013     8     1       22           2146       156      255             30\n4  2013     8     1       26           2051       215      333           2358\n5  2013     8     1       32           2359        33      420            344\n6  2013     8     1       33           2231       122      412            226\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.callout-important}\n\nWhen manipulating temporal information (date, time, duration), keep an eye on [what `lubridate` offers](https://lubridate.tidyverse.org). The API closely parallels what RDMS and Python offer. \n\n:::\n\n- Arrived more than two hours late, but didn’t leave late\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(arr_delay >= 120, dep_delay <= 0) |> \n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1    29\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Were delayed by at least an hour, but made up over 30 minutes in flight\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dep_delay > 60, \n         arr_delay < dep_delay -30) |> \n  count()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1  1819\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Departed between midnight and 6am (inclusive)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dep_time<=600, dep_time>0) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n1  2013     1     1      517            515         2      830            819\n2  2013     1     1      533            529         4      850            830\n3  2013     1     1      542            540         2      923            850\n4  2013     1     1      544            545        -1     1004           1022\n5  2013     1     1      554            600        -6      812            837\n6  2013     1     1      554            558        -4      740            728\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(lubridate::hour(time_hour)<=5  | (\n         lubridate::hour(time_hour)==6 & minute(time_hour)==0)) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n1  2013     1     1      517            515         2      830            819\n2  2013     1     1      533            529         4      850            830\n3  2013     1     1      542            540         2      923            850\n4  2013     1     1      544            545        -1     1004           1022\n5  2013     1     1      554            600        -6      812            837\n6  2013     1     1      554            558        -4      740            728\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n\n::: {.callout-important}\n\nRead [`filter()` in R for Data Science 1st Ed](https://r4ds.had.co.nz/transform.html#filter-rows-with-filter)\n\nRead [Chapter Transform in  R for Data Science 2nd Ed](https://r4ds.hadley.nz/data-transform)\n\n:::\n\n## Missing data\n\n- How many flights  per `origin` have a missing `dep_time`? \n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(is.na(dep_time)) |> \n  count(by=origin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  by        n\n  <chr> <int>\n1 EWR    3239\n2 JFK    1863\n3 LGA    3153\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(is.na(dep_time)) |> \n  count(by=origin) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `by`, COUNT(*) AS `n`\nFROM (\n  SELECT `nycflights13::flights`.*, `origin` AS `by`\n  FROM `nycflights13::flights`\n  WHERE ((`dep_time` IS NULL))\n) AS `q01`\nGROUP BY `by`\n```\n\n\n:::\n:::\n\n\n\n\nNot far from a spontaneous answer! We could obtain the latter anyway.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(is.na(dep_time)) |> \n  group_by(origin) |> \n  summarise(n=n()) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `origin`, COUNT(*) AS `n`\nFROM (\n  SELECT `nycflights13::flights`.*\n  FROM `nycflights13::flights`\n  WHERE ((`dep_time` IS NULL))\n) AS `q01`\nGROUP BY `origin`\n```\n\n\n:::\n:::\n\n\n\n\nNote that combining `dplyr` verbs and pipes (`|>` or `|>`) provides a much \nmore readable and modular approach than vanilla `SQL`. \n\n- Using `dplyr`  and pipe, the order in which operation are executed is clear and obvious. In SQL, it is counterintuitive.\n-  \n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n\nIn table `flights`, 8255 (`nrow(filter(flights, is.na(dep_time)))`) rows have a missing `dep_time` field. \n\n:::\n\n- What other variables are missing? \n\n\n::: {.callout-important}\n\nThe introduction to [`tidyselect`](https://tidyselect.r-lib.org) is a must read. \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(is.na(dep_time)) |> \n  summarize(across(everything(), ~ all(is.na(.)))) |> \n  pivot_longer(cols = everything()) |> \n  filter(value) |> \n  select(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 1\n  name     \n  <chr>    \n1 dep_time \n2 dep_delay\n3 arr_time \n4 arr_delay\n5 air_time \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  filter(is.na(dep_time)) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `nycflights13::flights`.*\nFROM `nycflights13::flights`\nWHERE ((`dep_time` IS NULL))\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- What might these rows with missing data represent?\n\n::: {.content-visible when-profile=\"solution\"} \n\nAll the information you can only get if the flight did take off. \n\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_cancelled <-  flights |> \n  filter(!is.na(dep_time))\n```\n:::\n\n\n\n\n<br> \n\n\n- More questions: for each column in `flight` report the number of missing values. \n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  summarise(across(everything(), ~  sum(is.na(.)))) |> \n  pivot_longer(cols = everything()) |> \n  filter(value > 0) |> \n  arrange(desc(value))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  name      value\n  <chr>     <int>\n1 arr_delay  9430\n2 air_time   9430\n3 arr_time   8713\n4 dep_time   8255\n5 dep_delay  8255\n6 tailnum    2512\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  skimr::skim()\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |        |\n|:------------------------|:-------|\n|Name                     |flights |\n|Number of rows           |336776  |\n|Number of columns        |19      |\n|_______________________  |        |\n|Column type frequency:   |        |\n|character                |4       |\n|numeric                  |14      |\n|POSIXct                  |1       |\n|________________________ |        |\n|Group variables          |None    |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|carrier       |         0|          1.00|   2|   2|     0|       16|          0|\n|tailnum       |      2512|          0.99|   5|   6|     0|     4043|          0|\n|origin        |         0|          1.00|   3|   3|     0|        3|          0|\n|dest          |         0|          1.00|   3|   3|     0|      105|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable  | n_missing| complete_rate|    mean|      sd|   p0|  p25|  p50|  p75| p100|hist  |\n|:--------------|---------:|-------------:|-------:|-------:|----:|----:|----:|----:|----:|:-----|\n|year           |         0|          1.00| 2013.00|    0.00| 2013| 2013| 2013| 2013| 2013|▁▁▇▁▁ |\n|month          |         0|          1.00|    6.55|    3.41|    1|    4|    7|   10|   12|▇▆▆▆▇ |\n|day            |         0|          1.00|   15.71|    8.77|    1|    8|   16|   23|   31|▇▇▇▇▆ |\n|dep_time       |      8255|          0.98| 1349.11|  488.28|    1|  907| 1401| 1744| 2400|▁▇▆▇▃ |\n|sched_dep_time |         0|          1.00| 1344.25|  467.34|  106|  906| 1359| 1729| 2359|▁▇▇▇▃ |\n|dep_delay      |      8255|          0.98|   12.64|   40.21|  -43|   -5|   -2|   11| 1301|▇▁▁▁▁ |\n|arr_time       |      8713|          0.97| 1502.05|  533.26|    1| 1104| 1535| 1940| 2400|▁▃▇▇▇ |\n|sched_arr_time |         0|          1.00| 1536.38|  497.46|    1| 1124| 1556| 1945| 2359|▁▃▇▇▇ |\n|arr_delay      |      9430|          0.97|    6.90|   44.63|  -86|  -17|   -5|   14| 1272|▇▁▁▁▁ |\n|flight         |         0|          1.00| 1971.92| 1632.47|    1|  553| 1496| 3465| 8500|▇▃▃▁▁ |\n|air_time       |      9430|          0.97|  150.69|   93.69|   20|   82|  129|  192|  695|▇▂▂▁▁ |\n|distance       |         0|          1.00| 1039.91|  733.23|   17|  502|  872| 1389| 4983|▇▃▂▁▁ |\n|hour           |         0|          1.00|   13.18|    4.66|    1|    9|   13|   17|   23|▁▇▇▇▅ |\n|minute         |         0|          1.00|   26.23|   19.30|    0|    8|   29|   44|   59|▇▃▆▃▅ |\n\n\n**Variable type: POSIXct**\n\n|skim_variable | n_missing| complete_rate|min                 |max                 |median              | n_unique|\n|:-------------|---------:|-------------:|:-------------------|:-------------------|:-------------------|--------:|\n|time_hour     |         0|             1|2013-01-01 05:00:00 |2013-12-31 23:00:00 |2013-07-03 10:00:00 |     6936|\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n## Arrange\n\n- How could you use `arrange()` to sort all missing values to the start? (Hint: use `is.na()`).\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Sort flights to find the most delayed flights. \n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(desc(dep_delay)) |> \n  select(dep_delay, arr_delay, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   dep_delay arr_delay  year month   day dep_time sched_dep_time arr_time\n       <dbl>     <dbl> <int> <int> <int>    <int>          <int>    <int>\n 1      1301      1272  2013     1     9      641            900     1242\n 2      1137      1127  2013     6    15     1432           1935     1607\n 3      1126      1109  2013     1    10     1121           1635     1239\n 4      1014      1007  2013     9    20     1139           1845     1457\n 5      1005       989  2013     7    22      845           1600     1044\n 6       960       931  2013     4    10     1100           1900     1342\n 7       911       915  2013     3    17     2321            810      135\n 8       899       850  2013     6    27      959           1900     1236\n 9       898       895  2013     7    22     2257            759      121\n10       896       878  2013    12     5      756           1700     1058\n# ℹ 336,766 more rows\n# ℹ 11 more variables: sched_arr_time <int>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n- Pick the ten most delayed flights (with finite `dep_delay`)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  slice_max(order_by=dep_delay, n = 10, na_rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- Find the flights that left earliest.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(dep_time) |> \n  select(dest, origin, dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n   dest  origin dep_time\n   <chr> <chr>     <int>\n 1 SYR   JFK           1\n 2 MDW   LGA           1\n 3 SJU   JFK           1\n 4 BQN   JFK           1\n 5 SJU   JFK           1\n 6 SJU   JFK           1\n 7 BQN   JFK           1\n 8 MDW   LGA           1\n 9 PWM   JFK           1\n10 PSE   JFK           1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- Sort flights to find the fastest (highest speed) flights.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(air_time)) |> \n  mutate(speed = distance/air_time) |> \n  arrange(desc(speed)) |> \n  select(speed, distance, air_time, origin, dest, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 327,346 × 20\n   speed distance air_time origin dest   year month   day dep_time\n   <dbl>    <dbl>    <dbl> <chr>  <chr> <int> <int> <int>    <int>\n 1 11.7       762       65 LGA    ATL    2013     5    25     1709\n 2 10.8      1008       93 EWR    MSP    2013     7     2     1558\n 3 10.8       594       55 EWR    GSP    2013     5    13     2040\n 4 10.7       748       70 EWR    BNA    2013     3    23     1914\n 5  9.86     1035      105 LGA    PBI    2013     1    12     1559\n 6  9.4      1598      170 JFK    SJU    2013    11    17      650\n 7  9.29     1598      172 JFK    SJU    2013     2    21     2355\n 8  9.27     1623      175 JFK    STT    2013    11    17      759\n 9  9.24     1598      173 JFK    SJU    2013    11    16     2003\n10  9.24     1598      173 JFK    SJU    2013    11    16     2349\n# ℹ 327,336 more rows\n# ℹ 11 more variables: sched_dep_time <int>, dep_delay <dbl>, arr_time <int>,\n#   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\nThis is an overkill. We are sorting in order to perform maximum selection. \nRecall that sorting requires more comparisons than selection. The comparison \nbetween sorting and selecting with respect to data shuffling is even less favourable.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(air_time)) |> \n  mutate(speed = distance/air_time) |>\n  slice_max(n=10, speed) |>\n  select(speed, distance, air_time, origin, dest, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 20\n   speed distance air_time origin dest   year month   day dep_time\n   <dbl>    <dbl>    <dbl> <chr>  <chr> <int> <int> <int>    <int>\n 1 11.7       762       65 LGA    ATL    2013     5    25     1709\n 2 10.8      1008       93 EWR    MSP    2013     7     2     1558\n 3 10.8       594       55 EWR    GSP    2013     5    13     2040\n 4 10.7       748       70 EWR    BNA    2013     3    23     1914\n 5  9.86     1035      105 LGA    PBI    2013     1    12     1559\n 6  9.4      1598      170 JFK    SJU    2013    11    17      650\n 7  9.29     1598      172 JFK    SJU    2013     2    21     2355\n 8  9.27     1623      175 JFK    STT    2013    11    17      759\n 9  9.24     1598      173 JFK    SJU    2013    11    16     2003\n10  9.24     1598      173 JFK    SJU    2013    11    16     2349\n11  9.24     1598      173 JFK    SJU    2013    11    17      851\n12  9.24     1598      173 JFK    SJU    2013    11    17     1926\n13  9.24     1598      173 JFK    SJU    2013    12     5     1858\n14  9.24     1598      173 JFK    SJU    2013     2    10     1658\n15  9.24     1598      173 JFK    SJU    2013     2    10     1958\n# ℹ 11 more variables: sched_dep_time <int>, dep_delay <dbl>, arr_time <int>,\n#   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n\n- Which flights travelled the farthest? \n\n\n::: {.callout-note collapse=\"true\"}\n\nThe database provides all we need with columns `distance` and `air_time`.  Otherwise, with the positions of airports from table `airports`, we should be able  to compute distances using : \n\n> ‘Haversine’ formula.\n\n[https://en.wikipedia.org/wiki/Haversine_formula](https://en.wikipedia.org/wiki/Haversine_formula)\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(desc(distance)) |> \n  distinct(distance, dest, origin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 226 × 3\n   distance dest  origin\n      <dbl> <chr> <chr> \n 1     4983 HNL   JFK   \n 2     4963 HNL   EWR   \n 3     3370 ANC   EWR   \n 4     2586 SFO   JFK   \n 5     2576 OAK   JFK   \n 6     2569 SJC   JFK   \n 7     2565 SFO   EWR   \n 8     2521 SMF   JFK   \n 9     2475 LAX   JFK   \n10     2465 LGB   JFK   \n# ℹ 216 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- Which travelled the shortest?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  arrange(distance) |> \n  select(distance, dest, origin, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   distance dest  origin  year month   day dep_time sched_dep_time dep_delay\n      <dbl> <chr> <chr>  <int> <int> <int>    <int>          <int>     <dbl>\n 1       17 LGA   EWR     2013     7    27       NA            106        NA\n 2       80 PHL   EWR     2013     1     3     2127           2129        -2\n 3       80 PHL   EWR     2013     1     4     1240           1200        40\n 4       80 PHL   EWR     2013     1     4     1829           1615       134\n 5       80 PHL   EWR     2013     1     4     2128           2129        -1\n 6       80 PHL   EWR     2013     1     5     1155           1200        -5\n 7       80 PHL   EWR     2013     1     6     2125           2129        -4\n 8       80 PHL   EWR     2013     1     7     2124           2129        -5\n 9       80 PHL   EWR     2013     1     8     2127           2130        -3\n10       80 PHL   EWR     2013     1     9     2126           2129        -3\n# ℹ 336,766 more rows\n# ℹ 10 more variables: arr_time <int>, sched_arr_time <int>, arr_delay <dbl>,\n#   carrier <chr>, flight <int>, tailnum <chr>, air_time <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nAvoid an overkill ...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  distinct(distance, origin, dest) |> \n  slice_min(distance, n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 3\n   distance origin dest \n      <dbl> <chr>  <chr>\n 1       17 EWR    LGA  \n 2       80 EWR    PHL  \n 3       94 JFK    PHL  \n 4       96 LGA    PHL  \n 5      116 EWR    BDL  \n 6      143 EWR    ALB  \n 7      160 EWR    PVD  \n 8      169 EWR    BWI  \n 9      173 JFK    MVY  \n10      184 JFK    BWI  \n11      184 LGA    BOS  \n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n## Projection\n\n- Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights.`\n\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note  title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(dep_time, dep_delay, arr_time, arr_delay) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  dep_time dep_delay arr_time arr_delay\n     <int>     <dbl>    <int>     <dbl>\n1      517         2      830        11\n2      533         4      850        20\n3      542         2      923        33\n4      544        -1     1004       -18\n5      554        -6      812       -25\n6      554        -4      740        12\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n::: {.callout-note  title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(starts_with(\"dep\"), starts_with(\"arr\")) |>  \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  dep_time dep_delay arr_time arr_delay\n     <int>     <dbl>    <int>     <dbl>\n1      517         2      830        11\n2      533         4      850        20\n3      542         2      923        33\n4      544        -1     1004       -18\n5      554        -6      812       -25\n6      554        -4      740        12\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n::: {.callout-note  title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(starts_with(\"dep_\") | starts_with(\"arr\")) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  dep_time dep_delay arr_time arr_delay\n     <int>     <dbl>    <int>     <dbl>\n1      517         2      830        11\n2      533         4      850        20\n3      542         2      923        33\n4      544        -1     1004       -18\n5      554        -6      812       -25\n6      554        -4      740        12\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n\n- What happens if you include the name of a variable multiple times in a `select()` call?\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note  title=\"Solution\"}\n\nIt is included once in the result. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  select(arr_time, starts_with(\"dep_\") | starts_with(\"arr\"), arr_time) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  arr_time dep_time dep_delay arr_delay\n     <int>    <int>     <dbl>     <dbl>\n1      830      517         2        11\n2      850      533         4        20\n3      923      542         2        33\n4     1004      544        -1       -18\n5      812      554        -6       -25\n6      740      554        -4        12\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- What does the `any_of()` function do? Why might it be helpful in conjunction with this vector?\n \n `vars <- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")`\n \n \n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvars <- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\n\nflights |> \n  filter(across(any_of(vars), is.numeric))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `across()` in `filter()` was deprecated in dplyr 1.0.8.\nℹ Please use `if_any()` or `if_all()` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(if_any(vars, \\(x) x<0)) |> \n  relocate(ends_with('delay')) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(vars)\n\n  # Now:\n  data %>% select(all_of(vars))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n  dep_delay arr_delay  year month   day dep_time sched_dep_time arr_time\n      <dbl>     <dbl> <int> <int> <int>    <int>          <int>    <int>\n1        -1       -18  2013     1     1      544            545     1004\n2        -6       -25  2013     1     1      554            600      812\n3        -4        12  2013     1     1      554            558      740\n4        -5        19  2013     1     1      555            600      913\n5        -3       -14  2013     1     1      557            600      709\n6        -3        -8  2013     1     1      557            600      838\n# ℹ 11 more variables: sched_arr_time <int>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n\n- Does the result of running the following code surprise you? \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n  flights, \n  contains(\"TIME\", ignore.case =TRUE))  |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  dep_time sched_dep_time arr_time sched_arr_time air_time time_hour          \n     <int>          <int>    <int>          <int>    <dbl> <dttm>             \n1      517            515      830            819      227 2013-01-01 05:00:00\n2      533            529      850            830      227 2013-01-01 05:00:00\n3      542            540      923            850      160 2013-01-01 05:00:00\n4      544            545     1004           1022      183 2013-01-01 05:00:00\n5      554            600      812            837      116 2013-01-01 06:00:00\n6      554            558      740            728      150 2013-01-01 05:00:00\n```\n\n\n:::\n:::\n\n\n\n\n::: {.content-visible when-profile=\"solution\"} \n\n:::\n\n- How do the select helpers deal with case by default? \n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note title=\"Solution\"}\n\nBy default, `select` helpers ignore case. \nThis complies with a similar behavior in RDBMS \n\n:::\n\n:::\n\n- How can you change that default?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, \n  contains(\"TIME\", ignore.case=FALSE))  |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 0\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n## Mutations\n\n\n- Currently `dep_time` and `sched_dep_time` are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(across(ends_with('dep_time') | ends_with('arr_time'), \n                (\\(x) 60L * (x %/% 100L) + (x %% 100L)),\n                .names=\"cor_{.col}\")) |>\n  select(ends_with('dep_time'), ends_with('arr_time'), everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 23\n   dep_time sched_dep_time cor_dep_time cor_sched_dep_time arr_time\n      <int>          <int>        <int>              <int>    <int>\n 1      517            515          317                315      830\n 2      533            529          333                329      850\n 3      542            540          342                340      923\n 4      544            545          344                345     1004\n 5      554            600          354                360      812\n 6      554            558          354                358      740\n 7      555            600          355                360      913\n 8      557            600          357                360      709\n 9      557            600          357                360      838\n10      558            600          358                360      753\n# ℹ 336,766 more rows\n# ℹ 18 more variables: sched_arr_time <int>, cor_arr_time <int>,\n#   cor_sched_arr_time <int>, year <int>, month <int>, day <int>,\n#   dep_delay <dbl>, arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\ndf <- flights |> \n  mutate(across(ends_with('dep_time') | ends_with('arr_time'), \n                (\\(x) 60L * (x %/% 100L) + (x %% 100L)),\n                .names=\"{.col}\"))\n```\n:::\n\n\n\n\n:::\n\n:::\n\n- Compare `air_time` with `arr_time - dep_time`. What do you expect to see? What do you see? What do you need to do to fix it?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(est_arr_time = (dep_time + air_time) %% 1440) |> \n  filter(abs(est_arr_time - arr_time)<1000) |> \n  arrange(desc(abs(est_arr_time - arr_time))) |> \n  select(dest, arr_time, est_arr_time, ends_with(\"time\"), everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 314,414 × 20\n   dest  arr_time est_arr_time dep_time sched_dep_time sched_arr_time air_time\n   <chr>    <int>        <dbl>    <int>          <int>          <int>    <dbl>\n 1 HNL        881         1226      594            600            890      632\n 2 HNL        858         1203      594            600            910      609\n 3 HNL        865         1210      594            600            900      616\n 4 HNL       1084         1429      810            815           1097      619\n 5 HNL        855         1199      598            600            890      601\n 6 HNL       1090         1434      815            809           1093      619\n 7 HNL        842         1186      585            600            885      601\n 8 HNL       1062         1405      809            809           1093      596\n 9 HNL        889         1232      597            600            890      635\n10 HNL        900         1243      597            600            930      646\n# ℹ 314,404 more rows\n# ℹ 13 more variables: year <int>, month <int>, day <int>, dep_delay <dbl>,\n#   arr_delay <dbl>, carrier <chr>, flight <int>, tailnum <chr>, origin <chr>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(est_arr_time = (dep_time + air_time) %% 1440) |> \n  filter(!is.na(arr_time), !is.na(est_arr_time)) |> \n  ggplot() +\n  aes(x = arr_time, y = est_arr_time) +\n  geom_point(alpha=.1, size=.1)\n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(est_arr_time = (dep_time + air_time) %% 1440) |> \n  filter(!is.na(arr_time), !is.na(est_arr_time)) |> \n  filter(abs(arr_time -est_arr_time) <600) |> \n  ggplot() +\n  aes(x = (arr_time -est_arr_time)%%60) +\n  stat_density() +\n  scale_x_continuous(breaks=seq(0, 60, 10))\n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Compare `dep_time`, `sched_dep_time`, and `dep_delay.` How would you expect those three numbers to be related?\n\n::: {.content-visible when-profile=\"solution\"} \n\n> We expect `dep_time == sched_dep_time + dep_delay %% 1440`\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  filter(!is.na(dep_time)) |> \n  mutate(est_dep_time = (sched_dep_time + dep_delay) %% 1440L) |> \n  ggplot() +\n  aes(x=dep_time, y=est_dep_time) +\n  geom_point(alpha=.1, size=.1) + \n  coord_fixed() \n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\nFor most of the flights, the discrepancy between `dep_time` and the computed value is `0`. \n\nFor `29` flights it is positive. The discrepancy is then exactly equal to `24` hours. \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  filter(!is.na(dep_time)) |> \n  mutate(discr = dep_time - (sched_dep_time + dep_delay) %% 1440L) |> \n  filter(discr > 0) |> \n  select(dest, origin, carrier, distance, discr) |> \n  left_join(airports, by=c(\"dest\"=\"faa\")) |> \n  arrange(carrier, desc(distance), dest) |> \n  select(dest, origin, carrier, name, discr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 29 × 5\n   dest  origin carrier name               discr\n   <chr> <chr>  <chr>   <chr>              <dbl>\n 1 MIA   LGA    AA      Miami Intl          1440\n 2 ORD   LGA    AA      Chicago Ohare Intl  1440\n 3 PSE   JFK    B6      <NA>                1440\n 4 PSE   JFK    B6      <NA>                1440\n 5 PSE   JFK    B6      <NA>                1440\n 6 PSE   JFK    B6      <NA>                1440\n 7 PSE   JFK    B6      <NA>                1440\n 8 PSE   JFK    B6      <NA>                1440\n 9 SJU   JFK    B6      <NA>                1440\n10 SJU   JFK    B6      <NA>                1440\n# ℹ 19 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Find the 10 most delayed flights using a ranking function. How do you want to handle ties? \n\n::: {callout-tip}\n\nCarefully read the documentation for `min_rank()`.\n\n[Windowed rank functions.]()\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dense_rank(-arr_delay) <=10) |> \n  arrange(desc(arr_delay)) |> \n  sample_n(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     9    20     1139           1845      1014     1457           2210\n 4  2013     6    15     1432           1935      1137     1607           2120\n 5  2013    12     5      756           1700       896     1058           2020\n 6  2013     7    22     2257            759       898      121           1026\n 7  2013     4    10     1100           1900       960     1342           2211\n 8  2013     7    22      845           1600      1005     1044           1815\n 9  2013     5     3     1133           2055       878     1250           2215\n10  2013     3    17     2321            810       911      135           1020\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n\n## Aggregations \n\n\n- Brainstorm at least 5 different ways to assess the typical delay characteristics of a group of flights. Consider the following scenarios:\n  + A flight is 15 minutes early 50% of the time, and 15 minutes late 10% of the time.\n  + A flight is always 10 minutes late.\n  + A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of the time.\n  + 99% of the time a flight is on time. 1% of the time it’s 2 hours late.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-note title=\"Solution\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_gp <- flights |> \n  group_by(flight, carrier, dest, origin) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_gp |> \n  summarize(q50 = quantile(arr_delay,.5, , na.rm=T), \n            q90 = quantile(arr_delay,.9, , na.rm=T),\n            .groups=\"drop\") |> \n  filter(q50<=-15, q90>=15) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  flight carrier dest  origin   q50   q90\n   <int> <chr>   <chr> <chr>  <dbl> <dbl>\n1      5 AS      SEA   EWR      -21  26.4\n2      6 DL      SLC   JFK      -18  20  \n3     10 UA      IAH   LGA      -19  28.5\n4     11 AS      SEA   EWR      -15  26.4\n5     31 DL      SFO   JFK      -22  17.2\n6     59 AA      SFO   JFK      -16  20.2\n```\n\n\n:::\n:::\n\n\n\n\nAnother approach builds on experimental `reframe()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile_df <- function(x, probs = c(0.5, 0.9)) {\n  tibble(\n    val = quantile(x, probs, na.rm = TRUE),\n    quant = probs\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- flights_gp |> \n  reframe(q= quantile_df(arr_delay)) |> \n  unnest(cols=q)\n```\n:::\n\n\n\n\n`reframe()` generates a list-column (a column is tibble-valued). The result \nhas to be *unnested*. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp |> \n  pivot_wider(\n    id_cols=c(flight, carrier, dest, origin),\n    names_from= quant,\n    values_from= val,\n    names_prefix=\"q\"\n  ) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  flight carrier dest  origin  q0.5   q0.9\n   <int> <chr>   <chr> <chr>  <dbl>  <dbl>\n1      1 AA      LAX   JFK    -13    19   \n2      1 B6      FLL   JFK      2    47.8 \n3      1 DL      SJU   JFK    -21    -6.40\n4      1 UA      ORD   EWR    -26   -26   \n5      1 UA      PBI   EWR    -19   -14.2 \n6      1 WN      MDW   LGA      2.5  33.6 \n```\n\n\n:::\n:::\n\n\n\n\n\n:::::\n\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarise(n_cancelled = sum(is.na(dep_time)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  n_cancelled\n   <chr>       <int>\n 1 ABQ             0\n 2 ACK             0\n 3 ALB            20\n 4 ANC             0\n 5 ATL           317\n 6 AUS            21\n 7 AVL            12\n 8 BDL            31\n 9 BGR            15\n10 BHM            25\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_lite |> \n  group_by(dest) |> \n  summarise(n_cancelled = sum(is.na(dep_time))) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Missing values are always removed in SQL aggregation functions.\nUse `na.rm = TRUE` to silence this warning\nThis warning is displayed once every 8 hours.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `dest`, SUM((`dep_time` IS NULL)) AS `n_cancelled`\nFROM `nycflights13::flights`\nGROUP BY `dest`\n```\n\n\n:::\n:::\n\n\n\n  \n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(flight, carrier, dest, origin) |> \n  summarize(q = quantile(arr_delay,.5, na.rm=T), m=mean(arr_delay, na.rm=TRUE)) |> \n  filter((q < -15) | (q > 15)) |> \n  arrange(desc(m))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'flight', 'carrier', 'dest'. You can\noverride using the `.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,161 × 6\n# Groups:   flight, carrier, dest [4,106]\n   flight carrier dest  origin     q     m\n    <int> <chr>   <chr> <chr>  <dbl> <dbl>\n 1    372 UA      CLE   LGA      455   455\n 2    488 UA      DEN   LGA      359   359\n 3    521 WN      BNA   EWR      335   335\n 4   5017 EV      DTW   LGA      334   334\n 5    468 UA      MCO   EWR      323   323\n 6    390 DL      DEN   LGA      318   318\n 7    809 DL      SLC   EWR      299   299\n 8   3261 EV      CLE   EWR      292   292\n 9   3760 9E      RIC   JFK      288   288\n10   1510 UA      IAH   EWR      283   283\n# ℹ 4,151 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(jour=lubridate::wday(time_hour, label=T, abbr = F)) |> \n  summarise(n_cancelled=sum(is.na(dep_time)), n_tot=n())  |> \n  mutate(prop_cancelled = n_cancelled/n_tot)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 4\n  jour     n_cancelled n_tot prop_cancelled\n  <ord>          <int> <int>          <dbl>\n1 dimanche         714 46357         0.0154\n2 lundi           1220 50690         0.0241\n3 mardi           1152 50422         0.0228\n4 mercredi        1202 50060         0.0240\n5 jeudi           1562 50219         0.0311\n6 vendredi        1608 50308         0.0320\n7 samedi           797 38720         0.0206\n```\n\n\n:::\n\n```{.r .cell-code}\n?lubridate::wday\n```\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Which is more important: arrival delay or departure delay?\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note title=\"Solution\"}\n\n:::\n\n:::\n\n- Come up with another approach that will give you the same output as `not_cancelled |> count(dest)` and ` (without using `count()`).\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_cancelled |> \n  summarise(n_distinct(dest), n_distinct(tailnum))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  `n_distinct(dest)` `n_distinct(tailnum)`\n               <int>                 <int>\n1                104                  4037\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Our definition of cancelled flights `(is.na(dep_delay) | is.na(arr_delay) )` is slightly suboptimal. Why? Which is the most important column?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(xor(is.na(arr_delay), is.na(dep_delay))) |> \n  group_by(is.na(arr_delay), is.na(dep_delay)) |> \n  summarise(n())\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'is.na(arr_delay)'. You can override using\nthe `.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n# Groups:   is.na(arr_delay) [1]\n  `is.na(arr_delay)` `is.na(dep_delay)` `n()`\n  <lgl>              <lgl>              <int>\n1 TRUE               FALSE               1175\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Look at the number of cancelled flights per day. Is there a pattern? Is the proportion of cancelled flights related to the average delay?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(day_of_week=wday(time_hour, label=TRUE)) |> \n  group_by(day_of_week) |> \n  summarise(n_cancelled= sum(is.na(arr_delay)), n(), prop= n_cancelled/n()) |> \n  ggplot() +\n  aes(x=day_of_week, y=prop) +\n  geom_col(width=.5) +\n  labs(title=\"Proportion of cancelled flights with respect to day of week\") +\n  xlab(\"Day of Week\") +\n  ylab(\"Proportion\")\n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-71-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Which carrier has the worst delays? \n\nChallenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about `flights |> group_by(carrier, dest) |> summarise(n())`)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(arr_delay)) |> \n  group_by(carrier, dest) |> \n  summarise(m=mean(arr_delay), q9=quantile(arr_delay, (c(9)/10)), nn=n()) |> \n  ungroup() |> \n  filter(min_rank(-nn) <50) |> \n  ggplot() +\n  aes(x=carrier, y=dest) +\n  geom_point(aes(color=q9, size=nn)) +\n  scale_color_viridis_c() +\n  scale_size_area()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'carrier'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-72-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n\n- What does the `sort` argument to `count()` do. When might you use it?\n\n::: {.content-visible when-profile=\"solution\"} \n\n\n::: {.callout-note title=\"Solution\"}\n\n\n:::\n\n:::\n\n\n## Miscellanea\n\n\n- Which `carriers` serve all destination airports (in the table) ?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  distinct(origin, dest) |> \n  mutate(tot_dest = n_distinct(dest)) |> \n  group_by(tot_dest, origin) |> \n  summarise(n_dest=n(), .groups=\"drop\") |> \n  filter(n_dest==tot_dest) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 3\n# ℹ 3 variables: tot_dest <int>, origin <chr>, n_dest <int>\n```\n\n\n:::\n:::\n\n\n\n\n{{< fa hand-point-right >}} Verb `mutate()` handles function `n_distinct()` as a window function with trivial window. \n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note}\nThere is  no need to perform grouping and aggregation to answer this question. Basic relational algebra is enough.  This operation is called *division* in SQL language\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nR <- flights |>\n    distinct(carrier, dest)\n\nC <- R |> distinct(carrier) \nD <- R |> distinct(dest)\n\nsetdiff(C, crossing(C, D) |> \n           setdiff(R) |> \n           distinct(carrier))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 1\n# ℹ 1 variable: carrier <chr>\n```\n\n\n:::\n:::\n\n\n\n\nLet $\\mathcal{R}(A, B$ be the schema of some table $R$, then  \n$$\nR \\div \\pi_B(R) = \\pi_A(R) \\setminus \\left(\\pi_A \\left(\\pi_A(R) \\times \\pi_B(R) \\setminus R \\right)\\right)\n$$\n\nMore generally if $S$ has schema $\\mathcal{S}(B)$\n$$\nR \\div S = \\pi_A(R) \\setminus \\left(\\pi_A \\left(\\pi_A(R) \\times \\pi_B(S) \\setminus R \\right)\\right)\n$$\n\n:::\n\n\n:::\n\n\n- Refer back to the lists of useful mutate and filtering functions. \n- Describe how each operation changes when you combine it with grouping.\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note title=\"Solution\"}\n\n:::\n\n:::\n\n- Which plane (`tailnum`) has the worst on-time record amongst planes with at least ten flights?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(arr_delay)) |> \n  group_by(tailnum) |> \n  summarise(m = mean(arr_delay), n_flights=n() ) |> \n  filter(n_flights > 10 ) |> \n  filter(min_rank(-m) == 1) |> \n  inner_join(distinct(flights, tailnum, carrier))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(tailnum)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  tailnum     m n_flights carrier\n  <chr>   <dbl>     <int> <chr>  \n1 N337AT   66.5        13 FL     \n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- What time of day should you fly if you want to avoid delays as much as possible?\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note title=\"Solution\"}\n\nDefinitely before 9a.m. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(arr_delay)) |> \n  group_by(hour) |> \n  summarise(m = mean(arr_delay, na.rm=T)) |> \n  arrange(m) |> \n  ggplot() + \n  aes(x=hour, y=m) +\n  geom_col(color=\"black\", fill=\"white\", alpha=.2) +\n  labs(title=\"Mean arrival delay as a function of departure hour\",\n       subtitle= \"nycflights13 data\")\n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-76-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- For each destination, compute the total minutes of delay. \n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n    filter(!is.na(arr_delay)) |>\n    group_by(dest) |>\n    summarise(m = sum(arr_delay, na.rm = T)) |> \n    arrange(desc(m)) |> \n    rename(faa=dest) |>\n    dplyr::inner_join(airports)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(faa)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 9\n   faa        m name                          lat    lon   alt    tz dst   tzone\n   <chr>  <dbl> <chr>                       <dbl>  <dbl> <dbl> <dbl> <chr> <chr>\n 1 ATL   190260 Hartsfield Jackson Atlanta…  33.6  -84.4  1026    -5 A     Amer…\n 2 CLT   100645 Charlotte Douglas Intl       35.2  -80.9   748    -5 A     Amer…\n 3 ORD    97352 Chicago Ohare Intl           42.0  -87.9   668    -6 A     Amer…\n 4 FLL    96153 Fort Lauderdale Hollywood …  26.1  -80.2     9    -5 A     Amer…\n 5 DCA    82609 Ronald Reagan Washington N…  38.9  -77.0    15    -5 A     Amer…\n 6 RDU    78107 Raleigh Durham Intl          35.9  -78.8   435    -5 A     Amer…\n 7 MCO    76185 Orlando Intl                 28.4  -81.3    96    -5 A     Amer…\n 8 IAD    74631 Washington Dulles Intl       38.9  -77.5   313    -5 A     Amer…\n 9 BNA    71867 Nashville Intl               36.1  -86.7   599    -6 A     Amer…\n10 DEN    61700 Denver Intl                  39.9 -105.   5431    -7 A     Amer…\n# ℹ 90 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n- For each flight, compute the proportion of the total positive arrival delays for its destination.\n\n::: {.content-visible when-profile=\"solution\"} \n\n::: {.callout-note title=\"Solution\"}\n\nWould be easy with `ROLLUP (dest, flight)`\n```{.sql}\nWITH R AS (\n  SELECT dest, flight, sum(arr_delay)\n  FROM flights\n  WHERE arr_delay >0\n  GROUP BY ROLLUP(dest, flight)\n)\nSELECT r1.dest, r2.flight, r2.sum/r1.sum AS rap\nFROM (SELECT dest, sum \n      FROM R WHERE flight IS NULL) r1 \n      JOIN R r2 \n      ON (r1.dest=r2.dest)\nWHERE r2.flight IS NOT NULL AND r2.sum/r1.sum >.1\nORDER BY r1.dest, r2.flight ;\n```\n\nWith `WINDOW` it is even easier\n\n:::\n\n:::\n\n\nUsing `dplyr`, it is easy. See [A second look at `group_by`](https://sebastiansauer.github.io/second_look_group_by/)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n   dplyr::filter(arr_delay >0 ) |> \n   group_by(dest, flight) |> \n   summarise(total_delay_flight=sum(arr_delay)) |> # result is a grouped tibble\n   mutate(total_delay_dest=sum(total_delay_flight), \n          delay_ratio= total_delay_flight/total_delay_dest)  |> \n  filter(dest %in% c('LAX', 'ATL'), delay_ratio > .02)   \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'dest'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 5\n# Groups:   dest [2]\n   dest  flight total_delay_flight total_delay_dest delay_ratio\n   <chr>  <int>              <dbl>            <dbl>       <dbl>\n 1 ATL      348               7000           300299      0.0233\n 2 ATL      926               9908           300299      0.0330\n 3 ATL      947               8670           300299      0.0289\n 4 ATL     1147               6968           300299      0.0232\n 5 ATL     1499               6155           300299      0.0205\n 6 ATL     1942               6224           300299      0.0207\n 7 ATL     2042              11583           300299      0.0386\n 8 ATL     4705               6458           300299      0.0215\n 9 LAX       21               8378           203226      0.0412\n10 LAX      119               4685           203226      0.0231\n11 LAX      133               5644           203226      0.0278\n12 LAX      169               6560           203226      0.0323\n13 LAX      181               8228           203226      0.0405\n14 LAX      185               5925           203226      0.0292\n15 LAX      413               6271           203226      0.0309\n16 LAX      415              10102           203226      0.0497\n17 LAX      523               5055           203226      0.0249\n18 LAX      535               6030           203226      0.0297\n19 LAX      771               6963           203226      0.0343\n20 LAX     2363               4273           203226      0.0210\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\nWe have used the fact that the output of `summarise(., total_delay_flight=sum(arr_delay))`\nis still a grouped dataframe/tibble (with grouping variable `dest`). At the following line, \n`mutate` performs aggregation with `sum()` in a groupwise manner, that is per group, and the \nresult of the aggregation is appended to each row of the group, because we use `mutate` instead\nof `summarize`. \n\n```{.sql}\nWITH R AS (\n  SELECT dest, \n         flight, \n         SUM(arr_delay)  AS  total_delay_per_flight\n  FROM flights\nWHERE arr_delay > 0 \nGROUP BY dest, flight\n) \nSELECT dest, flight, \n       total_delay_per_flight, \n       SUM(total_delay_per_flight) OVER w_per_dest AS     total_delay_per_dest \nFROM R\nWINDOW w_per_dest AS (PARTITION BY dest) ;\n```\n\n:::\n\n:::\n\n\n- Delays are typically temporally correlated: even once the problem that caused the initial delay has been resolved, later flights are delayed to allow earlier flights to leave. Using `lag()`, explore how the delay of a flight is related to the delay of the immediately preceding flight.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n    group_by(origin)  |> \n    arrange(year,month, day, sched_dep_time, .by_group=T) |>   # .by_group -> see documentation of arrange\n    mutate(prev_delay=lag(dep_delay, n=1L), prev_origin=lag(origin, n=1L)) |> \n    slice_head(n=6L) |>    # inspect the result \n    select(origin, prev_origin, dep_delay, prev_delay, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 21\n# Groups:   origin [3]\n   origin prev_origin dep_delay prev_delay  year month   day dep_time\n   <chr>  <chr>           <dbl>      <dbl> <int> <int> <int>    <int>\n 1 EWR    <NA>                2         NA  2013     1     1      517\n 2 EWR    EWR                -4          2  2013     1     1      554\n 3 EWR    EWR                -5         -4  2013     1     1      555\n 4 EWR    EWR                -2         -5  2013     1     1      558\n 5 EWR    EWR                -1         -2  2013     1     1      559\n 6 EWR    EWR                 1         -1  2013     1     1      601\n 7 JFK    <NA>                2         NA  2013     1     1      542\n 8 JFK    JFK                -1          2  2013     1     1      544\n 9 JFK    JFK                 0         -1  2013     1     1      559\n10 JFK    JFK                -3          0  2013     1     1      557\n11 JFK    JFK                -2         -3  2013     1     1      558\n12 JFK    JFK                -2         -2  2013     1     1      558\n13 LGA    <NA>                4         NA  2013     1     1      533\n14 LGA    LGA                -6          4  2013     1     1      554\n15 LGA    LGA                -3         -6  2013     1     1      557\n16 LGA    LGA                -2         -3  2013     1     1      558\n17 LGA    LGA                -1         -2  2013     1     1      559\n18 LGA    LGA                 0         -1  2013     1     1      600\n# ℹ 13 more variables: sched_dep_time <int>, arr_time <int>,\n#   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\n`lag()`  is an example of *window* function. If we were using `SQL`, we would define a `WINDOW`  using  an expression like \n\n```{.sql}\nWINDOW w As (PARTITION BY origin ORDER BY year, month, day, sched_dep_time)\n``` \n\nSomething still needs fixing here: some flights never took off (`is.na(dep_time)`). Should they be sided out? assigned an infinite departure delay? \n\n:::\n\n\n- Look at each destination. Can you find flights that are suspiciously fast? (i.e. flights that represent a potential data entry error). Compute the air time of a flight relative to the shortest flight to that destination. Which flights were most delayed in the air?\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- flights |> \n    filter(!is.na(air_time), air_time > 0) |> \n    mutate(speed= (distance * 1.852)/ (air_time/60)) \n      \np1 <- df |> \n    ggplot() +\n        aes(x=origin, y=speed) +\n        geom_boxplot()\n\np2 <- df |> \n    ggplot() +\n        aes(x=speed) +\n        geom_histogram(color=\"black\", fill=\"white\", alpha=.2)\n\n\npatchwork::wrap_plots(p1 + p2 )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-80-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 + geom_rug(alpha=.5) +\n    facet_zoom(xlim=c(900,1500))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-81-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\nConsider all flights with average speed above $950\\text{km/h}$\nas suspicious. \n\nLet us visualize destinations and origins of the speedy flights.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n    filter(speed>950) |> \n    mutate(dest=as_factor(dest)) |> \n    ggplot() +\n        aes(x=fct_infreq(dest)) +\n        geom_bar()\n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-82-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n`SJU`, `BQN` are located in Puerto Rico. `LAX` is Los Angeles airport. `STT` is located in Virgin Islands. \n:::\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n    filter(speed>950, ! dest %in% c('SJU', 'BQN')) |> \n    mutate(dest=as_factor(dest)) |> \n    ggplot() +\n        aes(x=fct_infreq(dest), fill=origin) +\n        geom_bar() +\n        labs(x=\"Destination\", \n        title=\"Distribution of speedy flights\",\n        subtitle=\"Excluding SJU and BQN\")\n```\n\n::: {.cell-output-display}\n![](lab-tables_files/figure-html/unnamed-chunk-83-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n\n- Find all destinations that are flown by at least two carriers. Use that information to rank the carriers.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n:::\n\n:::\n\n- For each plane, count the number of flights before the first delay  greater than 1 hour.\n\n::: {.callout-note collapse=\"true\"}\nAssume a plane is characterized by `tailnum`. Some flights have no `tailnum`. We ignore them. \n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"Solution\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(!is.na(tailnum)) |> \n  group_by(tailnum) |> \n  arrange(year, month, day, sched_dep_time, .bygroup=T) |> \n  mutate(rnk=row_number(), tot=n()) |> \n  filter(is.na(arr_time) | arr_delay >=60) |> \n  slice_head(n=1)  |> \n  mutate(rel_rnk = rnk/tot) |> \n  select(tailnum, rnk, tot,  rel_rnk, carrier) |> \n  arrange(desc(tot), desc(rel_rnk)) |> \n  ungroup() \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,454 × 5\n   tailnum   rnk   tot rel_rnk carrier\n   <chr>   <int> <int>   <dbl> <chr>  \n 1 N725MQ     17   575 0.0296  MQ     \n 2 N722MQ     31   513 0.0604  MQ     \n 3 N723MQ     24   507 0.0473  MQ     \n 4 N711MQ     24   486 0.0494  MQ     \n 5 N713MQ      4   483 0.00828 MQ     \n 6 N258JB      8   427 0.0187  B6     \n 7 N298JB     17   407 0.0418  B6     \n 8 N353JB     34   404 0.0842  B6     \n 9 N351JB     10   402 0.0249  B6     \n10 N735MQ      3   396 0.00758 MQ     \n# ℹ 3,444 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n## References\n\n\n- [Data transformation cheatsheet](https://rstudio.github.io/cheatsheets/html/data-transformation.html)\n- [R4Data Science Tidy](https://r4ds.had.co.nz/tidy-data.html#tidy-data-1)\n- [Benchmarking](https://h2oai.github.io/db-benchmark/)\n- [`dplyr` and `vctrs`](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-and-vctrs/)\n- [Posts on `dplyr`](https://www.tidyverse.org/tags/dplyr/)\n- [Window functions on `dplyr`](https://dplyr.tidyverse.org/articles/window-functions.html)\n\n\n\n\n\n{{< video https://www.youtube.com/watch?v=Ue08LVuk790 >}}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}