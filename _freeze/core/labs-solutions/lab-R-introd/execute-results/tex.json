{
  "hash": "6bfa50f270ebde47a3152cdc334ce535",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R language: a tour\"\ncategories: [R, Vectors, Lists, Arrays, Data.frames, Functions]\ndate: \"2025-01-14 21:20:41.355047\"\n\nexecute:\n  warning: false\n  message: false\n  cache: false\n  echo: true\n  eval: true \n  include: true\n  collapse: false\n  output: true\n  fig.retina: 4\n  fig.height: 4\n\nformat:\n  html:\n    output-file: lab-r-intro.html\n    execute: \n      eval: true\n      collapse: false\n      echo: true\n    code-annotations: hover\n    code-fold: false\n  pdf:\n    output-file: lab-r-intro.pdf\nprefer-html: true\n\nengine: knitr\n---\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| Ann√©e {{< var year >}}     |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n::: {.callout-important}\n\n### Objectives\n\nThis workbook intends to walk you through basic aspects of the `R` language and programming environment.\n\n:::\n\n\n\n## Packages\n\nBase [`R`](https://r-project.org) can do a lot. But the full power of `R` comes\nfrom a [fast growing collection of `packages`](https://cran.r-project.org/web/packages/available_packages_by_date.html).\n\nPackages are first *installed* (that is downloaded from `cran` and copied somewhere on the hard drive), and if needed, *loaded* during a session.\n\n- Installation can usually be performed using command `install.packages()`. In some circumstances, ad hoc installation commands (often from packages  `devtools`) are needed\n- Package `pak` offers an interesting alternative to base `R` `install.packages()`\n- Once a package has been installed/downloaded on your hard drive\n  + if you want all objects exported by the package to be available in your session, you should *load* the package, using `library()` or `require()` (what's the difference?). Technically, this loads the `NameSpace` defined by the package.\n  + if you just want to pick some objects exported from the package, you can use *qualified names* like `package_name::object_name` to access the object (function, dataset, ...). \n \nFor example, when we write \n\n```{.r}  \ngapminder <- gapminder::gapminder\n```\n\nwe assign dataframe/tibble `gapminder` from package `gapminder` to identifier `\"gapminder\"`  in global environment  {{< fa meh-rolling-eyes >}}. \n\n\nFunction `p_load()` from `pacman` (package manager) blends installation and loading: if the package named in the argument of `p_load()` is not installed (not among the `installed.packages()`), `p_load()` attempts to install the package. If installation is successful, the package is loaded.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (! require(pak)){\n  install.packages(\"pak\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(\n  require(\"tidyverse\"), \n  require(\"lobstr\"),\n  require(\"ggforce\"),\n  require(\"nycflights13\"),\n  require(\"patchwork\"), \n  require(\"viridis\"),\n  require(\"MASS\"),\n  require(\"gapminder\"),\n  require(\"pryr\"),\n  require(\"pak\")\n)\n```\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Optional arguments\n\nA very nice feature of `R` is that functions from base `R` as well as from packages have *optional* arguments with sensible *default* values. Look for example at documentation of `require()` using expression `?require`.\n\nOptional settings may concern individual functions or the collection of functions exported by some packages. In the next *chunk*, we reset the default color scales used by graphical functions from `ggplot2`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopts <- options()  # save old options\n\noptions(ggplot2.discrete.colour=\"viridis\")\noptions(ggplot2.continuous.colour=\"viridis\")\n```\n:::\n\n\n\n\n\n\n:::\n\n::: {.callout-important}\n\n### {{< fa hand-point-right >}} \n\nYou shall not confuse *installing* (on your hard-drive) and *loading* (in session) a package.\n\n:::\n\n::: {.callout-note}\n\n### Question for Pythonistas\n\n- In {{< fa brands python >}} what is the analogue of `install.packages()`?\n- In {{< fa brands python >}} what is the analogue of `require()/library()`?\n  \n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip}\n\n### Solution\n\nIn  {{< fa brands python >}}, you can install a package `pck` using `pip install pck` or `conda install pck` (for example).\n\nIn  {{< fa brands python >}}, the analogue of `require(pck)` could be \n\n```{.python}\nfrom pck import *\n```\n\nNote that in `R`, once a package in installed on the hard drive, you do not need to write something like \n\n```{.python}\nimport pck\n```\n\nto be able to use objects exported by `pck` using qualified names (like `pck.ze_object`), you just need to use `R` qualified names:\n\n```{.r}\npck::ze_object\n```\n\n::: \n:::\n\n\n# Numerical (atomic) vectors\n\nNumerical (atomic) vectors form the most primitive type of `R`.\n\n## Vector creation and assignment\n\nThe next three lines create three numerical atomic vectors.\n\nIn IDE `Rstudio`, have a look at the `environment` pane\non the right before running the chunk, and after.\n\nUse `ls()` to investigate the _environment_ before and after \nthe execution of the three assignments.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nls()\nx <- c(1, 2, 12)\ny <- 5:7\nz <- 10:1\nx ; y ; z \nls()\n```\n:::\n\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\n- What are the identifiers known in the global environment before execution of lines 2-4?\n- What are the identifiers known in the global environment after execution of lines 2-4?\n- Which objects are attached to identifiers `x, y,` and `z`?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"opts\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- c(1, 2, 12)\ny <- 5:7\nz <- 10:1\nx ; y ; z \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2 12\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n\n\n:::\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"opts\" \"x\"    \"y\"    \"z\"   \n```\n\n\n:::\n:::\n\n\n\n\n\nThe chunks adds three identifiers `x,y,z` to the global environment. \nIdentifiers are bound to `R` objects which turn out to be numerical vectors. \n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nWhat does the next chunk?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\nw <- y\nls()\n```\n:::\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe chunk inserts a new identifier `w` in the global environment. This identifier is associated with the same object as `y`.\n\n::::: \n\n:::\n\n::: {.callout-note}\n\n### Question\n\n- Is the content of object denoted by `y` copied to a new object\nbound to `w`?\n- Interpret the result of `w == y`.\n- Interpret the result of `identical(w,y)` (use `help(\"identical\")` if needed). \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw == y \nidentical(w,y)\n```\n:::\n\n\n\n\n\n\n::: \n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\" collapse=\"false\"}\n\n\nPackage `lobstr` lets us explore low-level aspects of `R` (and much more). Function `lobstr::obj_addr()` returns the address of  the object denoted by the argument. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::obj_addr(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd11c78890\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd11c78890\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, if we modify either `y` or `w`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- y + 1\nidentical(y, w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(lobstr::obj_addr(w), lobstr::obj_addr(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd11c78890\" \"0x5bfd0c43e678\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe address associated with `y` has changed!\n\n:::::\n\n::: {.callout-warning}\n\n### {{< fa hand-point-right >}}\n\nThe meaning  of assignment in `R` differs from its counterpart in `Python`. In `Python`, assignment is shallow. In `R`, assignment creates a new identifier bound to the same object as the right-hand side of the assignment. If either side of the assignment is modified, it is copied to a new object before modification. This is called *copy-on-modify*.\n\n:::\n\n:::\n\n## Indexation, slicing, modification\n\nSlicing a vector can be done in two ways:\n\n- providing a vector of indices to be selected. Indices need not be consecutive.\n- providing a Boolean mask, that is a logical vector to select a set of positions.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 12) ; y <- 5:7 ; z <- 10:1\n```\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\nExplain the next lines\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[1]   # slice of length 1\nz[0]   # What did you expect?\nz[x]   # slice of length ??? index error ?\nz[y]\nz[x %% 2]   # what happens with x[0] ?\nz[0 == (x %% 2)] # masking\nz[c(2, 1, 1)]\n```\n:::\n\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n\n\n\n\n\n\n\n- Indices start at `1` (not like in `C`, `Java`, or `Python`)\n- {{< fa hand-point-right >}} `z[0]` does not return an Error message. It returns an empty vector with the same basetype as `x`\n- `z[x]` returns a vector made of `z[x[1]], z[x[2]]` and `z[x[3]]==z[12]`. Note again that `z[12]` does not raise an exception. It is simply not available (`NA`). \n- `x %% 2` returns `1 0 0` as `%%` stands for `mod`. `z[x %% 2]` returns the same thing as `z[1]`\n\n`c( )` stands for combine, or concatenate. \n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nIf the length of mask and and the length of the sliced vector do not coincide, what happens? \n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\nNo error is signaled, the returned sequence is as long as the number of truthies in the mask. \n\nOut of bound truthies show up as `NA`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[rep(c(TRUE, FALSE), 6)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  8  6  4  2 NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### {{< fa hand-point-right >}}\n\nA scalar is just a vector of length $1$!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(z[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(z[c(2,1)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nExplain the next lines\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[2:3] <- z[2:3]\ny == z[-10]\n\nz[-11]\n```\n:::\n\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n\n\n\n\n\n\nWe can assign a slice of a vector to a slice of identical size of another vector.\n\nWhat is the result of `z[-11]`, `z[-c(11:7)]`?\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nExplain the next line\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[-(1:5)]\n```\n:::\n\n\n\n\n\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n\n\n\n\n\n\nWe pick all positions in `z` but the ones in `1:5`, that is 6, 7, 8, 9, 10\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nHow would you select the last element from a vector (say `z`)?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[length(z)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n:::::\n\n::: {.callout-caution}\n\n### {{< fa hand-point-right >}}\n\n{{< fa brands r-project >}} is not {{< fa brands python >}} (reminder)!\n\n:::\n\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nReverse the entries of a vector. Find two ways to do that.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[seq(length(z), 1, by=-1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nz[length(z):1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nrev(z)   # the simplest way, once you know rev()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\nIn statistics, machine learning, we are often faced with the task of \nbuilding grids of regularly spaced elements (these elements can be numeric or not). `R` offers a collection of tools to perform this. The most basic tool is `rep()`.\n\n::: {.callout-note}\n\n### Question\n\n- Repeat a vector $2$ times\n- Repeat each element of a vector twice\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- c(1, 7, 9)\nrep(w, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 7 9 1 7 9\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(w, rep(2, length(w)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 7 7 9 9\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, we can try something more fancy. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(w, 1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 7 7 9 9 9\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat are the requirements on the second (`times`) argument?\n\n:::::\n\n:::\n\nLet us remove objects from the global environment.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(w, x, y ,z)\n```\n:::\n\n\n\n\n\n\n## Numbers \n\nSo far, we told about numeric vectors. Numeric vectors are vectors of floating point numbers. \n`R` distinguishes several kinds of numbers. \n\n- Integers \n- Floating point numbers (`double`)\n\nTo check whether a vector is made  of `numeric` or of `integer`, use `is.numeric()` or `is.integer()`. Use `as.integer`, `as.numeric()` to enforce  type conversion. \n\n::: {.callout-note}\n\n### Question\n\nExplain the outcome of the next chunks\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(113L) ; class(113) ; class(113L + 113) ; class(2 * 113L) ; class(pi) ; as.integer(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfloor(pi) ; class(floor(pi)) # mind the floor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n## Integer arithmetic\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n29L * 31L ; 899L %/% 32L ; 899L %% 30L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 899\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 29\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-caution}\n\n`R` integers are not the natural numbers from Mathematics\n\n`R` numerics are not the real numbers from Mathematics\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.Machine$double.eps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.220446e-16\n```\n\n\n:::\n\n```{.r .cell-code}\n.Machine$double.xmax\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.797693e+308\n```\n\n\n:::\n\n```{.r .cell-code}\n.Machine$sizeof.longlong\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nu <- double(19L)\nv <- numeric(5L)\nw <- integer(7L)\nlapply(list(u, v, w), typeof)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"double\"\n\n[[2]]\n[1] \"double\"\n\n[[3]]\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(c(u, v, w))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(c(u, v, w))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n`R` is (sometimes) able to make sensible use of Infinite.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n0/0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(c( 0/0,1,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(c(NA,1,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(c(-Inf,1,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nis.finite(c(-Inf,1,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(c(NA,1,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.nan(c(NaN,1,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Computing with vectors\n\nSumming, scalar multiplication\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\ny <- 9:7\n\nsum(x) ; prod(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nz <- cumsum(1:3)\nw <- cumprod(3:5)\n\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 10 10\n```\n\n\n:::\n\n```{.r .cell-code}\nx + z\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5 9\n```\n\n\n:::\n\n```{.r .cell-code}\n2 * w\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   6  24 120\n```\n\n\n:::\n\n```{.r .cell-code}\n2 + w\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 14 62\n```\n\n\n:::\n\n```{.r .cell-code}\nw / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.5  6.0 30.0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\nHow would you compute a factorial?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 10\ncumprod(1:n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]       1       2       6      24     120     720    5040   40320  362880\n[10] 3628800\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nApproximate $\\sum_{n=1}^\\infty 1/n^2$ within $10^{-3}$?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n$$\\sum_{n > N} \\frac{1}{n^2} < \\sum_{n > N} \\frac{1}{n(n-1)} = \\sum_{n > N} \\left(\\frac{1}{n-1}-\\frac{1}{n}\\right) = \\frac{1}{N}$$\nSo we may pick $N=1000$. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x*y) # inner product\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 46\n```\n\n\n:::\n\n```{.r .cell-code}\nprod(1:5) # factorial(n) as prod(1:n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120\n```\n\n\n:::\n\n```{.r .cell-code}\nN <- 1000L\nsum(1/((1:N)^2)) ; pi^2/6 # grand truth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.643935\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.644934\n```\n\n\n:::\n\n```{.r .cell-code}\n(pi^2/6 - sum(1/((1:N)^2))) < 1e-3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# N <- 999L\n# (pi^2/6 - sum(1/((1:N)^2))) < 1e-3\n```\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question \n\nHow would you compute the inner product between two (atomic numeric) vectors?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n\n::::: {.callout title=\"Solution\" collapse=\"false\"} \n\nInner product between two vectors can be computed as a matrix product between a row vector and a column vector using `%*%`. Is this a good idea?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(w, ncol=3) %*% matrix(y, nrow=3) == sum(w * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\nWhat we have called `vectors` so far are indeed `atomic vectors`.\n\n- Read [Chapter on Vectors in `R advanced Programming`](https://adv-r.hadley.nz/vectors-chap.html)\n- Keep an eye on package [`vctrs`](https://vctrs.r-lib.org/) for getting insights into the `R` vectors.\n\n:::\n\n# Numerical matrices\n\n`R` offers a `matrix` class. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1:50, nrow=5)\nA \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    6   11   16   21   26   31   36   41    46\n[2,]    2    7   12   17   22   27   32   37   42    47\n[3,]    3    8   13   18   23   28   33   38   43    48\n[4,]    4    9   14   19   24   29   34   39   44    49\n[5,]    5   10   15   20   25   30   35   40   45    50\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note}\n\n### Question \n\nFrom the evaluation of the preceding chunk, can you guess whether it is easier the traverse a matrix in row-first order or in column-first order? \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"} \n\nDefault traversal seems to proceed columnwise. \n\n:::::\n\n:::\n\n## Creation, transposition and reshaping\n\nA vector can be turned into a column matrix.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- as.matrix(1:5)\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n[5,]    5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nA matrix can be transposed\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(v)  # transpose \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(dim(v), ' ', dim(t(v)), '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5 1   1 5 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1, nrow=5, ncol=2) ; A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    1\n[2,]    1    1\n[3,]    1    1\n[4,]    1    1\n[5,]    1    1\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\n`lobstr::mem_used()` allows us to keep track of the amount of memory used by our `R` session. `lobstr::obj_size()` tells us the amount of memory used by the representation of an object.\n\nComment the next chunk\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <-lobstr::mem_used()\nA <- matrix(rnorm(100000L), nrow=1000L)\nm2 <- lobstr::mem_used()\nlobstr::obj_size(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n800.22 kB\n```\n\n\n:::\n\n```{.r .cell-code}\nB <- t(A)\nlobstr::obj_size(B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n800.22 kB\n```\n\n\n:::\n\n```{.r .cell-code}\nm3 <- lobstr::mem_used()\nm2-m1 ; m3-m2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n802.44 kB\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.09 MB\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n::: {.content-hidden}\n::: {.callout-note}\n\n### {{< fa brands python >}}\n\n<!-- TODO -->\n\n:::\n:::\n\n::: {.callout-note}\n\n### Question\n\n- Is there a difference between the next two assignments?\n- How would you assign value to all entries of a matrix?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(rnorm(16), nrow=4)\nA[] <- 0 ; A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0    0    0    0\n[4,]    0    0    0    0\n```\n\n\n:::\n\n```{.r .cell-code}\nA   <- 0 ; A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"} \n\nThere is! \n\nThe first assignment assigns `0` to every entry in `A`.\n\nThe second assignment binds `0` to name `A`\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nWhat is the final shape of `A`?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1, nrow=5, ncol=2) \nA\nA[] <- 1:15 \nA\n```\n:::\n\n\n\n\n\n\n:::\n\n\nWe can easily generate diagonal matrices and constant matrices.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(1, 3)  # building identity matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n\n\n:::\n\n```{.r .cell-code}\nmatrix(0, 3, 3) # building null matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n[3,]    0    0    0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question \n\nIs there any difference between the next two assignments?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nB <- A[]\nB ; A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(B) ; lobstr::obj_addr(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd1103f610\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd117c5f38\"\n```\n\n\n:::\n\n```{.r .cell-code}\nB <- A\nlobstr::obj_addr(B) ; lobstr::obj_addr(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd117c5f38\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd117c5f38\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n\n::: {.content-visible when-profile=\"solutio\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\nLa premi√®re affectation, assigne une copie de la matrice `A` √† l'idenficateur `\"B\"`. \n\nLa seconde affectation assigne l'objet d√©not√© par `\"A\"` √† l'identificateur `\"B\"`. \n\nQue se passera-t-il si on ex√©cute ensuite :\n\n```{.r}\nB[2, 2] <- 113\n```\n\n:::::\n\n:::\n\n## Indexation, slicing, modification\n\nIndexation consists in getting one item from a vector/list/matrix/array/dataframe.\n\nSlicing and subsetting consists in picking a substructure:\n\n- subsetting a vector returns a vector\n- subsetting a list returns a list\n- subsetting a matrix/array returns a matrix/array (beware of implicit simplifications and dimension dropping)\n- subsetting a dataframe returns a dataframe or a vector (again, beware of implicit simplifications).\n\n\n::: {.callout-note}\n\n### Question\n\nExplain the next results\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1, nrow=5, ncol=2)\n\ndim(A[sample(5, 3), -1])\ndim(A[sample(5, 3), 1])\nlength(A[sample(5, 3), 1])\nis.vector(A[sample(5, 3), 1])\nA[10:15]\nA[60]\ndim(A[])\n```\n:::\n\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip}\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 NA NA NA NA NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nHow would you create a fresh copy of a matrix?\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip}\n\n### Solution\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(rnorm(10), ncol=2L)\nB <- matrix(0, nrow=5L, ncol=2L)\n\nB[] <- A\nall(B==A) ; identical(A, B) ; lobstr::obj_addrs(list(A, B))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd10887ea8\" \"0x5bfd108886e8\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: \n \n:::\n\n\n## Computing with matrices\n\n`*` versus `%*%`\n: `%*%` stands for matrix multiplication. In order to use it, the two matrices should have conformant dimensions.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(v) %*% A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]     [,2]\n[1,] -3.347265 5.831594\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere are a variety of reasonable products around. Some of them are available in `R`.\n\n::: {.callout-note}\n\n### Question\n\nHow would you compute the Hilbert-Schmidt inner product between\ntwo matrices?\n\n$$\\langle A, B\\rangle_{\\text{HS}} = \\text{Trace} \\big(A \\times B^\\top\\big)$$\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\nIn `R`, `trace()` does not return the trace of a matrix! Function is used for debugging. \n\nJust remember that the trace of a matrix is the sum of its diagonal elements. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(runif(6), 2, 3)\nB <- matrix(runif(6), 2, 3)\nfoo <- sum(diag(A %*% t(B)))\nbar <- sum(A * B)\nfoo ; bar\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.526855\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.526855\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAre you surprised? \n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nHow can you invert a square (invertible) matrix? \n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\nUse `solve(A)` which is a shorthand for `solve(A, diag(1, nrow(3)))`. \n\n:::\n\n\n# Logicals\n\n- `R` has constants `TRUE` and `FALSE`.\n- Numbers can be coerced to `logicals`.\n\n::: {.callout-note}\n\n### Question\n\n- Which numbers are truthies? falsies?\n- What is the value (if any) of `! pi & TRUE` ?\n- What is the meaning of `all( )` ?\n- What is the meaning of `any( )` ?\n- Recall *De Morgan's laws*. Check them with `R`.\n- Is `|` denoting an inclusive or an exclusive OR?\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip}\n\n### Solution\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- c(TRUE, FALSE, FALSE)\n\nsum(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nany(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nall(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!w\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE  & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: \n:::\n\n\n\n## Handling three-valued logic\n\n::: {.callout-note}\n\n### Question\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE &  (1> (0/0))\n(1> (0/0)) | TRUE\n(1> (0/0)) | FALSE\nTRUE || (1> (0/0))\nTRUE |  (1> (0/0))\nTRUE || stopifnot(4<3)\n# TRUE |  stopifnot(4<3)  \nFALSE && stopifnot(4<3)\n# FALSE & stopifnot(4<3)\n```\n:::\n\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip}\n\n### Solution\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE &  (1> (0/0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n(1> (0/0)) | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n(1> (0/0)) | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE || (1> (0/0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE |  (1> (0/0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE || stopifnot(4<3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# TRUE |  stopifnot(4<3)  \nFALSE && stopifnot(4<3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# FALSE & stopifnot(4<3)\n```\n:::\n\n\n\n\n\n::: \n:::\n\n\n::: {.callout-note}\n\n### Question\n\nWhat is the difference between logical operators `||`  and `|` ?\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n`||` is *lazy*. It does not evaluate its second argument if the\nfirst one evaluates to `TRUE`.\n\n`&&` is also lazy.\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### {{< fa hand-point-right >}}\n\nRemark: favor `&, |` over `&&, ||`.\n\n:::\n\n## `all` and `any`\n\nLook at the definition of `all` and `any`.\n\n::: {.callout-note}\n\n### Question\n\n- How would you check that a square matrix is symmetric?\n- How would you check that a matrix is diagonal?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n \nA square matrix is symmetric iff it is equal to its transpose. \nRecall that `t(A)` denotes the transpose of matrix `A`. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(rnorm(9), nrow=3, ncol=3) # a.s. non-symmetric\nall(A == t(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nA <- A %*% t(A)  # build a symmetric matrix, A + t(A) would work also\nall(A == t(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n`A == t(A)` returns a matrix a logical matrix, whose entries are all `TRUE` iff\n`A` is symmetric. \n\n`all()` works for matrices as well as for vectors. This is sensible as matrices can be considered as vectors with some additional structure.  \n\n:::::\n\n:::\n\n# Lists\n\nWhile an instance of an atomic `vector` contains objects of the same type/class, an instance of  `list` may contain  objects of widely different types.\n\n::: {.callout-note}\n\n### Question\n\nCheck an explain the output of the next chunk\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- c(2, 7, 8)\nq <- c(\"A\", \"B\", \"C\")\nx <- list(p, q)\nx[2]\nx\nlength(x)\nrlang::is_vector(x)\nrlang::is_atomic(x)\ny <- c(p, q)\ny\nlength(y)\nrlang::is_atomic(y)\nrlang::is_list(y)\n```\n:::\n\n\n\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2 7 8\n\n[[2]]\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\" \"7\" \"8\" \"A\" \"B\" \"C\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n`lobstr::tree( )` shows the structure of `x` and of `y`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Question\n#| label: enigma-list-2\n#| eval: true\nlobstr::tree(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<list>\n‚îú‚îÄ<dbl [3]>2, 7, 8\n‚îî‚îÄ<chr [3]>\"A\", \"B\", \"C\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::tree(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<chr [6]>\"2\", \"7\", \"8\", \"A\", \"B\", \"C\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n::: {.callout-note}\n\n### Question\n\n- How would you build a list made of `p`, `q`, and `x`?\n- What is `x[2]` made of?\n- How does it compare with `x[[2]]`?\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnl <- list(p=p, q=q, x=x)\nnl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$p\n[1] 2 7 8\n\n$q\n[1] \"A\" \"B\" \"C\"\n\n$x\n$x[[1]]\n[1] 2 7 8\n\n$x[[2]]\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that we have defined a *named* list. Each `=` expression, binds \nthe string on the left-hand side to the object on the right-hand side.\nList elements can be extracted in defferent ways.  \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(nl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"p\" \"q\" \"x\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnl$q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnl[[\"q\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnl[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nRead and understand the next expressions.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_atomic(p);  is_atomic(p[2]) ; is_atomic(p[[2]])\n\nis_list(q); is_atomic(q)\n\nis_list(x); is_atomic(x) ; class(x)\n\nclass(x[2]) ; class(x[[2]])\nlength(x[2]) ; length(x[[2]])\n\nidentical(q, x[[2]]) ; identical(q, x[2])\n\nobj_addr(q) ; obj_addr(x[[2]]) ; obj_addr(x[2])\nref(x)\nobj_addrs(x)\nidentical(x[2],x[[2]])\n```\n:::\n\n\n\n\n\n\n:::\n\n::: {.callout-note}\n\nFunctions `is_atomic(), is_list(), ..., obj_addr()` are from packages `rlang` and  `lobstr`. See [https://rlang.r-lib.org](https://rlang.r-lib.org) and  [https://lobstr.r-lib.org](https://lobstr.r-lib.org)\n\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n`p` and `a` are atomic vectors with different base types. They are not lists. A list like `x` is not an atomic vector.\n\nInspection of object addresses shows that when building `x` from objects `p` and `q`, objects bound to `\"p\"` and `\"q\"` are not copied. \n\nNote that `x[[2]]` and `x[2]` are different objects, the former is one element list, the second is an atomic vector.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ref(x[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n‚ñà [1:0x5bfd10fd4638] <list> \n‚îî‚îÄ[2:0x5bfd096da948] <chr> \n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(x[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x5bfd096da948\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nHow would you replace `\"A\"` in `x` with `\"K\"`?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[2]][1] <- \"K\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2 7 8\n\n[[2]]\n[1] \"K\" \"B\" \"C\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlobstr::ref(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n‚ñà [1:0x5bfd112a5d38] <list> \n‚îú‚îÄ[2:0x5bfd096d9278] <dbl> \n‚îî‚îÄ[3:0x5bfd1140fc18] <chr> \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- c(2, 7, 8)\nv <- c(\"A\", \"B\", \"C\")\nx <- list(w, v)\n```\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-important}\n\nRead [Chapter on Lists in `R advanced Programming`](https://adv-r.hadley.nz/vectors-chap.html#lists)\n\n:::\n\n\n\n# Lookup tables (aka dictionaries) using named vectors\n\n\nA lookup table maps strings to values. It can be implemented\nusing named vectors. If we want to map: `\"seine\"` to `\"75\"`, `\"loire\"` to `\"42\"`,\n`\"rhone\"` to `\"69\"`, `\"savoie\"` to `\"73\"` we can proceed in the following way:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes <- c(75L, 42L, 69L, 73L)\nnames(codes) <- c(\"seine\", \"loire\", \"rh√¥ne\", \"savoie\")\n\ncodes[\"rh√¥ne\"];  codes[\"aube\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nrh√¥ne \n   69 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<NA> \n  NA \n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question \n\nWhat is the class of `codes` ?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"seine\"  \"loire\"  \"rh√¥ne\"  \"savoie\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(codes); class(names(codes))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis_atomic(codes); is_character(codes) ; is_integer(codes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nCapitalize the `names` used by `codes`\n\n:::\n\n::: {.callout-tip}\n\nPackage `stringr` offers a function `str_to_title()` that could be of interest.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(codes) <- stringr::str_to_title(names(codes))\ncodes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Seine  Loire  Rh√¥ne Savoie \n    75     42     69     73 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n\n\n# Factors\n\nFactors exist in Base `R`. They play a very important role. Qualitative/Categorical variables are implemented as Factors.\n\nMeta-package `tidyverse` offers a package dedicated to `factor` engineering: `forcats`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyraw <- c(\"g1\",\"g1\",\"g2\",\"g2\",\"g2\",\"g3\")\nprint(yraw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"g1\" \"g1\" \"g2\" \"g2\" \"g2\" \"g3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(yraw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Length     Class      Mode \n        6 character character \n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(yraw) ; is.atomic(yraw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\n`yraw` takes few values. It makes sense to make it a `factor`.\nHow does it change the behavior of _generic_ function `summary` ?\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip}\n\n### Solution\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfyraw <- as.factor(yraw)\nlevels(fyraw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"g1\" \"g2\" \"g3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(fyraw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ng1 g2 g3 \n 2  3  1 \n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n \n:::\n\nLoad  the (celebrated) `iris` dataset, and inspect variable `Species`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\n\nspecies <- iris$Species\n\nlevels(species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"setosa\"     \"versicolor\" \"virginica\" \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    setosa versicolor  virginica \n        50         50         50 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\nWe may want to collapse `virginica`  and `versicolor` into a single level called `versinica`\n\n:::\n\n::: {.callout-tip}\n\n`forcats` offer a function `fct_collapse()`.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_species <- forcats::fct_collapse(\n  species,\n  versinica = c(\"versicolor\", \"virginica\")\n)\n\nsummary(col_species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   setosa versinica \n       50       100 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\nFactors are used to represent _categorical_ variables.\n\n::: {.callout-tip}\n\n### Question\n\n- Load the `whiteside` data from package `MASS`.\n- Have a glimpse.\n- Assign column `Insul` to `y`\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhiteside <- MASS::whiteside  # importing the whiteside data\n# ?whiteside                  # what are the whiteside data about?\n\ntibble::glimpse(whiteside)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 56\nColumns: 3\n$ Insul <fct> Before, Before, Before, Before, Before, Before, Before, Before, ~\n$ Temp  <dbl> -0.8, -0.7, 0.4, 2.5, 2.9, 3.2, 3.6, 3.9, 4.2, 4.3, 5.4, 6.0, 6.~\n$ Gas   <dbl> 7.2, 6.9, 6.4, 6.0, 5.8, 5.8, 5.6, 4.7, 5.8, 5.2, 4.9, 4.9, 4.3,~\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- whiteside$Insul          # picking a factor column\n```\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\n- What is the `class` of `y`?\n- Is `y` a `vector`\n- Is `y` _ordered_? What does  _ordered_ mean here?\n- What are the `levels` of `y` ? How many levels has `y`?\n- Can you slice `y` ?\n- What are the binary representations of the different levels of `y`?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.factor(y) ; is.vector(y) ; is.ordered(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Before\" \"After\" \n```\n\n\n:::\n\n```{.r .cell-code}\nnlevels(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ny[1:10] # yes we can\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] Before Before Before Before Before Before Before Before Before Before\nLevels: Before After\n```\n\n\n:::\n\n```{.r .cell-code}\npryr::bits(y[31]) # looks like the two levels are represented by integers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"00000000 00000000 00000000 00000010\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nSummarize factor `y`\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(y)   # counts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBefore  After \n    26     30 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(y)     # one-way contingency table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny\nBefore  After \n    26     30 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(y)/sum(table(y))*100   # one-way contingency table as percentages\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny\n  Before    After \n46.42857 53.57143 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(y) |>\n  knitr::kable(col.names = c(\"Insulation\", \"Frequency\"), \n               caption = \"Whiteside data\")  # Pb encoding sur machine windows\n```\n\n::: {.cell-output-display}\n\n\nTable: Whiteside data\n\n|Insulation | Frequency|\n|:----------|---------:|\n|Before     |        26|\n|After      |        30|\n\n\n:::\n\n```{.r .cell-code}\nforcats::fct_count(y) |>\n  knitr::kable(col.names = c(\"Insulation\", \"Frequency\"), \n               caption = \"Whiteside data\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Whiteside data\n\n|Insulation | Frequency|\n|:----------|---------:|\n|Before     |        26|\n|After      |        30|\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n### Factors nuts and bolts\n\nWhen coercing a vector (integer, character, ...) to a factor,\nuse `forcats::as_factor()` rather than base `R` `as.factor()`.\n\n::: {.callout-tip}\n\n{{< fa hand-point-right >}} Useful function to make nice `barplots` when constructing `barplots`. \n\nRecall  that when you want to display counts for a univariate _categorical_ sample, you use a `barplot`.  It is often desirable to rank the levels according to the displayed statistics (usually a count).\n\nThis can be done in a seamless way using functions like `forcats::fct_infreq()`.\n\n:::\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforcats::fct_count(y, prop = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 3\n  f          n     p\n  <fct>  <int> <dbl>\n1 Before    26 0.464\n2 After     30 0.536\n```\n\n\n:::\n\n```{.r .cell-code}\nz <- sample(y, length(y), replace = TRUE)  # permutation of whiteside$Insul\n\nsort(forcats::fct_infreq(z))       # first level is most frequent one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] After  After  After  After  After  After  After  After  After  After \n[11] After  After  After  After  After  After  After  After  After  After \n[21] After  After  After  After  After  After  After  After  After  After \n[31] After  After  After  Before Before Before Before Before Before Before\n[41] Before Before Before Before Before Before Before Before Before Before\n[51] Before Before Before Before Before Before\nLevels: After Before\n```\n\n\n:::\n\n```{.r .cell-code}\nforcats::fct_count(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  f          n\n  <fct>  <int>\n1 Before    23\n2 After     33\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\nMake `z` ordered with level `After` preceding `Before`. Does ordering impact the behavior of `forcats::fct_count()`?\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforcats::fct_count(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  f          n\n  <fct>  <int>\n1 Before    23\n2 After     33\n```\n\n\n:::\n\n```{.r .cell-code}\nforcats::fct_count(factor(z, ordered=TRUE, levels=c(\"After\", \"Before\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  f          n\n  <ord>  <int>\n1 After     33\n2 Before    23\n```\n\n\n:::\n\n```{.r .cell-code}\nforcats::fct_count(forcats::fct_infreq(z))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  f          n\n  <fct>  <int>\n1 After     33\n2 Before    23\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhiteside |>\n  ggplot2::ggplot() + \n  ggplot2::aes(x=forcats::fct_infreq(Insul), fill=Insul) +\n  ggplot2::geom_bar() +\n  ggplot2::xlab(\"After and Before Insulation\") +\n  ggplot2::theme_minimal() +\n  ggplot2::theme(legend.position=\"None\") +\n  labs(title=\"Whiteside data\",\n    subtitle=\"Insulation frequency: showcasing fct_infreq()\", \n    caption=\"Source: MASS::whiteside\")\n```\n\n::: {.cell-output-display}\n![](lab-R-introd_files/figure-pdf/plot-factors-whiteside-ordered-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n::: {.callout-important}\n\nRead [Chapter on Factors in `R for Data Science`](https://r4ds.hadley.nz/factors)\n\n\n:::\n\n# Dataframes, `tibbles` and `data.tables`\n\nA dataframe is a list of vectors with equal lengths. This is the\nway `R` represents and manipulates multivariate\nsamples.\n\nAny software geared at data science supports some kind of dataframe\n\n- `Python` `Pandas`\n- `Python` `Dask`\n- `Spark`\n- ...\n\nThe `iris` dataset is the \"Hello world!\" of dataframes.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\n\niris |>\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.~\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.~\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.~\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.~\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nA `matrix` can be transformed into a `data.frame`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(rnorm(10), ncol=2)\ndata.frame(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          X1          X2\n1  0.3154053  0.92831162\n2 -0.1985439 -0.03596093\n3  1.8245245 -0.42075403\n4 -1.1246573  0.71939810\n5  0.4828221 -0.71660605\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere are several flavors of dataframes in `R`:\n`tibble` and `data.table` are modern variants of `data.frame`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt <- tibble::tibble(\n  x=1:3, \n  a=letters[11:13], \n  d=Sys.Date() + 1:3)\n\nhead(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n      x a     d         \n  <int> <chr> <date>    \n1     1 k     2025-01-15\n2     2 l     2025-01-16\n3     3 m     2025-01-17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 3\n$ x <int> 1, 2, 3\n$ a <chr> \"k\", \"l\", \"m\"\n$ d <date> 2025-01-15, 2025-01-16, 2025-01-17\n```\n\n\n:::\n\n```{.r .cell-code}\nref(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n‚ñà [1:0x5bfd1112f808] <tibble[,3]> \n‚îú‚îÄx = [2:0x5bfd0f95df80] <int> \n‚îú‚îÄa = [3:0x5bfd111f5168] <chr> \n‚îî‚îÄd = [4:0x5bfd11198078] <date> \n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-important}\n\nRead [Chapter on data frames and tibbles in Advanced R](https://adv-r.hadley.nz/vectors-chap.html#tibble)\n\n\n:::\n\n::: {.callout-note}\n### Question\n\nPerform a random permutation of the columns of a data.frame/tibble.\n\n:::\n\n::: {.callout-tip}\n\nFunction `sample()` from base `R` is very convenient\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt[sample(names(t))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  d          a         x\n  <date>     <chr> <int>\n1 2025-01-15 k         1\n2 2025-01-16 l         2\n3 2025-01-17 m         3\n```\n\n\n:::\n\n```{.r .cell-code}\n# or\nt[sample(ncol(t))]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  d          a         x\n  <date>     <chr> <int>\n1 2025-01-15 k         1\n2 2025-01-16 l         2\n3 2025-01-17 m         3\n```\n\n\n:::\n:::\n\n\n\n\n\n:::::\n\n:::\n\n\n\n# `nycflights` data\n\nWrestling with tables is part of the data scientist job.  Out of the box data are often messy. In order to perform useful data analysis, we need *tidy* data. The notion of tidy data was elaborated during the last decade by experienced data scientists. \n\nYou may benefit from looking at the following online documents. \n\n[Tidy data  in R for Data Science](https://r4ds.had.co.nz/tidy-data.html)\n\nIntroduction to [Table manipulation in R for Data Science](https://r4ds.had.co.nz/transform.html) in `R`.\n\nMore data of that kind is available following guidelines from\n[https://github.com/hadley/nycflights13](https://github.com/hadley/nycflights13)\n\nIn this exercise, you are advised to use functions from [dplyr](https://dplyr.tidyverse.org).\n\n> `dplyr` is a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- nycflights13::flights\n```\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\n- Have a glimpse at the data.\n- What is the `class` of object `data`?\n- What kind of object is `data`?\n\n\n:::\n\n__Hint:__ use `class(), is.data.frame() tibble::is_tibble()`\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: flight_glimpse\n#| eval: true\ndata |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2~\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, ~\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, ~\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1~\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,~\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,~\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1~\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"~\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4~\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394~\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",~\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",~\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1~\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, ~\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6~\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0~\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0~\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.data.frame(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_tibble(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nExtract the name and the type of each column.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(data)              # name of columns \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"year\"           \"month\"          \"day\"            \"dep_time\"      \n [5] \"sched_dep_time\" \"dep_delay\"      \"arr_time\"       \"sched_arr_time\"\n [9] \"arr_delay\"      \"carrier\"        \"flight\"         \"tailnum\"       \n[13] \"origin\"         \"dest\"           \"air_time\"       \"distance\"      \n[17] \"hour\"           \"minute\"         \"time_hour\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(data, class)         # old school R, a dataframe is a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$year\n[1] \"integer\"\n\n$month\n[1] \"integer\"\n\n$day\n[1] \"integer\"\n\n$dep_time\n[1] \"integer\"\n\n$sched_dep_time\n[1] \"integer\"\n\n$dep_delay\n[1] \"numeric\"\n\n$arr_time\n[1] \"integer\"\n\n$sched_arr_time\n[1] \"integer\"\n\n$arr_delay\n[1] \"numeric\"\n\n$carrier\n[1] \"character\"\n\n$flight\n[1] \"integer\"\n\n$tailnum\n[1] \"character\"\n\n$origin\n[1] \"character\"\n\n$dest\n[1] \"character\"\n\n$air_time\n[1] \"numeric\"\n\n$distance\n[1] \"numeric\"\n\n$hour\n[1] \"numeric\"\n\n$minute\n[1] \"numeric\"\n\n$time_hour\n[1] \"POSIXct\" \"POSIXt\" \n```\n\n\n:::\n\n```{.r .cell-code}\nlapply(data, class)         # old school R, a dataframe is a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$year\n[1] \"integer\"\n\n$month\n[1] \"integer\"\n\n$day\n[1] \"integer\"\n\n$dep_time\n[1] \"integer\"\n\n$sched_dep_time\n[1] \"integer\"\n\n$dep_delay\n[1] \"numeric\"\n\n$arr_time\n[1] \"integer\"\n\n$sched_arr_time\n[1] \"integer\"\n\n$arr_delay\n[1] \"numeric\"\n\n$carrier\n[1] \"character\"\n\n$flight\n[1] \"integer\"\n\n$tailnum\n[1] \"character\"\n\n$origin\n[1] \"character\"\n\n$dest\n[1] \"character\"\n\n$air_time\n[1] \"numeric\"\n\n$distance\n[1] \"numeric\"\n\n$hour\n[1] \"numeric\"\n\n$minute\n[1] \"numeric\"\n\n$time_hour\n[1] \"POSIXct\" \"POSIXt\" \n```\n\n\n:::\n\n```{.r .cell-code}\npurrr::map(data, class)            # tidyverse way\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$year\n[1] \"integer\"\n\n$month\n[1] \"integer\"\n\n$day\n[1] \"integer\"\n\n$dep_time\n[1] \"integer\"\n\n$sched_dep_time\n[1] \"integer\"\n\n$dep_delay\n[1] \"numeric\"\n\n$arr_time\n[1] \"integer\"\n\n$sched_arr_time\n[1] \"integer\"\n\n$arr_delay\n[1] \"numeric\"\n\n$carrier\n[1] \"character\"\n\n$flight\n[1] \"integer\"\n\n$tailnum\n[1] \"character\"\n\n$origin\n[1] \"character\"\n\n$dest\n[1] \"character\"\n\n$air_time\n[1] \"numeric\"\n\n$distance\n[1] \"numeric\"\n\n$hour\n[1] \"numeric\"\n\n$minute\n[1] \"numeric\"\n\n$time_hour\n[1] \"POSIXct\" \"POSIXt\" \n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n### Compute the mean of the numerical columns\n\nBase `R` has plenty of functions that perform statistical computations on univariate samples. Look at the documentation of `mean` (just type `?mean`). For a while, leave aside the optional arguments.\n\nIn database  parlance, we are performing _aggregation_\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(data$dep_delay)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# mean(data[[\"dep_delay\"]])\n```\n:::\n\n\n\n\n\n\nIf we want the mean of all numerical columns, we need to project the data frame on numerical columns.\n\nA verb of the [`summarize`](https://dplyr.tidyverse.org/reference/summarise.html) family can be useful.\n\n::: {.callout-tip}\n\nHave a look at `across` in latest versions of `dplyr()`\n\n\nUse `across()` from `dplyr` 1.x.  See [Documentation](https://dplyr.tidyverse.org/reference/across.html)\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |>\n  dplyr::select(where(is.numeric)) |>  # projecting on numerical columns\n  purrr::map(mean)                      # applying the treatment to each column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$year\n[1] 2013\n\n$month\n[1] 6.54851\n\n$day\n[1] 15.71079\n\n$dep_time\n[1] NA\n\n$sched_dep_time\n[1] 1344.255\n\n$dep_delay\n[1] NA\n\n$arr_time\n[1] NA\n\n$sched_arr_time\n[1] 1536.38\n\n$arr_delay\n[1] NA\n\n$flight\n[1] 1971.924\n\n$air_time\n[1] NA\n\n$distance\n[1] 1039.913\n\n$hour\n[1] 13.18025\n\n$minute\n[1] 26.2301\n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::select(where(is.numeric)) |>  # projecting on numerical columns\n  dplyr::summarise(across(everything(), mean, na.rm=T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 14\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <dbl> <dbl> <dbl>    <dbl>          <dbl>     <dbl>    <dbl>          <dbl>\n1  2013  6.55  15.7    1349.          1344.      12.6    1502.          1536.\n# i 6 more variables: arr_delay <dbl>, flight <dbl>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::summarise(across(where(is.numeric), mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 14\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <dbl> <dbl> <dbl>    <dbl>          <dbl>     <dbl>    <dbl>          <dbl>\n1  2013  6.55  15.7       NA          1344.        NA       NA          1536.\n# i 6 more variables: arr_delay <dbl>, flight <dbl>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::summarise(across(.cols=where(is.numeric), .fns=mean, na.rm=T))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 14\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <dbl> <dbl> <dbl>    <dbl>          <dbl>     <dbl>    <dbl>          <dbl>\n1  2013  6.55  15.7    1349.          1344.      12.6    1502.          1536.\n# i 6 more variables: arr_delay <dbl>, flight <dbl>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\nIf applied to a data.frame, `summary()`, produces a summary of each column. The summary depends on the column type.\nThe output of `summary` is a shortened version the list of outputs obtained from applying `summary` to each column (`lapply(data, summary)`).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |>\n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      year          month             day           dep_time    sched_dep_time\n Min.   :2013   Min.   : 1.000   Min.   : 1.00   Min.   :   1   Min.   : 106  \n 1st Qu.:2013   1st Qu.: 4.000   1st Qu.: 8.00   1st Qu.: 907   1st Qu.: 906  \n Median :2013   Median : 7.000   Median :16.00   Median :1401   Median :1359  \n Mean   :2013   Mean   : 6.549   Mean   :15.71   Mean   :1349   Mean   :1344  \n 3rd Qu.:2013   3rd Qu.:10.000   3rd Qu.:23.00   3rd Qu.:1744   3rd Qu.:1729  \n Max.   :2013   Max.   :12.000   Max.   :31.00   Max.   :2400   Max.   :2359  \n                                                 NA's   :8255                 \n   dep_delay          arr_time    sched_arr_time   arr_delay       \n Min.   : -43.00   Min.   :   1   Min.   :   1   Min.   : -86.000  \n 1st Qu.:  -5.00   1st Qu.:1104   1st Qu.:1124   1st Qu.: -17.000  \n Median :  -2.00   Median :1535   Median :1556   Median :  -5.000  \n Mean   :  12.64   Mean   :1502   Mean   :1536   Mean   :   6.895  \n 3rd Qu.:  11.00   3rd Qu.:1940   3rd Qu.:1945   3rd Qu.:  14.000  \n Max.   :1301.00   Max.   :2400   Max.   :2359   Max.   :1272.000  \n NA's   :8255      NA's   :8713                  NA's   :9430      \n   carrier              flight       tailnum             origin         \n Length:336776      Min.   :   1   Length:336776      Length:336776     \n Class :character   1st Qu.: 553   Class :character   Class :character  \n Mode  :character   Median :1496   Mode  :character   Mode  :character  \n                    Mean   :1972                                        \n                    3rd Qu.:3465                                        \n                    Max.   :8500                                        \n                                                                        \n     dest              air_time        distance         hour      \n Length:336776      Min.   : 20.0   Min.   :  17   Min.   : 1.00  \n Class :character   1st Qu.: 82.0   1st Qu.: 502   1st Qu.: 9.00  \n Mode  :character   Median :129.0   Median : 872   Median :13.00  \n                    Mean   :150.7   Mean   :1040   Mean   :13.18  \n                    3rd Qu.:192.0   3rd Qu.:1389   3rd Qu.:17.00  \n                    Max.   :695.0   Max.   :4983   Max.   :23.00  \n                    NA's   :9430                                  \n     minute        time_hour                     \n Min.   : 0.00   Min.   :2013-01-01 05:00:00.00  \n 1st Qu.: 8.00   1st Qu.:2013-04-04 13:00:00.00  \n Median :29.00   Median :2013-07-03 10:00:00.00  \n Mean   :26.23   Mean   :2013-07-03 05:22:54.64  \n 3rd Qu.:44.00   3rd Qu.:2013-10-01 07:00:00.00  \n Max.   :59.00   Max.   :2013-12-31 23:00:00.00  \n                                                 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Handling NAs\n\nWe add now a few `NA`s to the data....\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 <- data\ndata2$arr_time[1:10] <- NA\n```\n:::\n\n\n\n\n\n::: {.callout-caution}\n\nHouston, we have a problem! \n\n:::\n\n::: {.callout-note}\n\n### Question \n\n\nHow should we compute the column means now?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 |>\n  dplyr::summarise(across(is.numeric, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 14\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <dbl> <dbl> <dbl>    <dbl>          <dbl>     <dbl>    <dbl>          <dbl>\n1  2013  6.55  15.7       NA          1344.        NA       NA          1536.\n# i 6 more variables: arr_delay <dbl>, flight <dbl>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\nIt is time to look at *optional* arguments of function `mean`.\n\n::: {.callout-note}\n\n### Question\n\nDecide to ignore `NA` and to compute the mean with the available data\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 |>\n  dplyr::summarise(across(is.numeric, mean, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 14\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <dbl> <dbl> <dbl>    <dbl>          <dbl>     <dbl>    <dbl>          <dbl>\n1  2013  6.55  15.7    1349.          1344.      12.6    1502.          1536.\n# i 6 more variables: arr_delay <dbl>, flight <dbl>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nIt is possible to remove all rows that contain at least one `NA`.\n\nShow this leads to a different result.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 |> \n  drop_na() |> \n  dplyr::summarise(across(where(is.numeric), mean, na.rm=FALSE)) |>\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| year|    month|      day| dep_time| sched_dep_time| dep_delay| arr_time| sched_arr_time| arr_delay|   flight| air_time| distance|     hour|   minute|\n|----:|--------:|--------:|--------:|--------------:|---------:|--------:|--------------:|---------:|--------:|--------:|--------:|--------:|--------:|\n| 2013| 6.564973| 15.74127| 1348.814|       1340.359|  12.55559| 1501.929|        1532.81|  6.895471| 1943.121| 150.6863| 1048.373| 13.14124| 26.23435|\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nCompute the minimum, the median, the mean and the maximum of numerical columns\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 |>\n  dplyr::select_if(is.numeric) |>\n  lapply(function(x) c(med=median(x, na.rm=TRUE),\n                       avg=mean(x, na.rm=TRUE),\n                       max=max(x, na.rm=TRUE))\n         )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$year\n med  avg  max \n2013 2013 2013 \n\n$month\n     med      avg      max \n 7.00000  6.54851 12.00000 \n\n$day\n     med      avg      max \n16.00000 15.71079 31.00000 \n\n$dep_time\n    med     avg     max \n1401.00 1349.11 2400.00 \n\n$sched_dep_time\n     med      avg      max \n1359.000 1344.255 2359.000 \n\n$dep_delay\n       med        avg        max \n  -2.00000   12.63907 1301.00000 \n\n$arr_time\n     med      avg      max \n1536.000 1502.075 2400.000 \n\n$sched_arr_time\n    med     avg     max \n1556.00 1536.38 2359.00 \n\n$arr_delay\n        med         avg         max \n  -5.000000    6.895377 1272.000000 \n\n$flight\n     med      avg      max \n1496.000 1971.924 8500.000 \n\n$air_time\n     med      avg      max \n129.0000 150.6865 695.0000 \n\n$distance\n     med      avg      max \n 872.000 1039.913 4983.000 \n\n$hour\n     med      avg      max \n13.00000 13.18025 23.00000 \n\n$minute\n    med     avg     max \n29.0000 26.2301 59.0000 \n```\n\n\n:::\n\n```{.r .cell-code}\n  data2 |>\n  dplyr::summarise(across(where(is.numeric), \n                          c(median=median,mean=mean, max=max), \n                          na.rm=T))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 42\n  year_median year_mean year_max month_median month_mean month_max day_median\n        <dbl>     <dbl>    <int>        <dbl>      <dbl>     <int>      <dbl>\n1        2013      2013     2013            7       6.55        12         16\n# i 35 more variables: day_mean <dbl>, day_max <int>, dep_time_median <int>,\n#   dep_time_mean <dbl>, dep_time_max <int>, sched_dep_time_median <dbl>,\n#   sched_dep_time_mean <dbl>, sched_dep_time_max <int>,\n#   dep_delay_median <dbl>, dep_delay_mean <dbl>, dep_delay_max <dbl>,\n#   arr_time_median <int>, arr_time_mean <dbl>, arr_time_max <int>,\n#   sched_arr_time_median <dbl>, sched_arr_time_mean <dbl>,\n#   sched_arr_time_max <int>, arr_delay_median <dbl>, arr_delay_mean <dbl>, ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nObtain a *nicer* output!\n\nCheck with [https://dplyr.tidyverse.org/reference/scoped.html?q=funs#arguments](https://dplyr.tidyverse.org/reference/scoped.html?q=funs#arguments)\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2 |>\n  dplyr::summarise(across(where(is.numeric),\n                          list(median=median,\n                               mean=mean,\n                               max=max),\n                          na.rm=TRUE)\n  ) |>\n  tidyr::pivot_longer(cols=everything(), names_to=\"stat\", values_to=\"value\") |>\n  head() |> \n  gt::gt() |>\n  gt::fmt_number(columns=\"value\", decimals=2)\n```\n\n::: {.cell-output-display}\n\\begingroup\n\\fontsize{12.0pt}{14.4pt}\\selectfont\n\\begin{longtable}{lr}\n\\toprule\nstat & value \\\\ \n\\midrule\\addlinespace[2.5pt]\nyear\\_median & 2,013.00 \\\\ \nyear\\_mean & 2,013.00 \\\\ \nyear\\_max & 2,013.00 \\\\ \nmonth\\_median & 7.00 \\\\ \nmonth\\_mean & 6.55 \\\\ \nmonth\\_max & 12.00 \\\\ \n\\bottomrule\n\\end{longtable}\n\\endgroup\n\n:::\n:::\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nMimic `summary` on numeric columns\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmysum <- data2 |>\n  dplyr::summarise(across(is.numeric,\n                          list(median=median,\n                               mean=mean,\n                               max=max,\n                               min=min,\n                               sd=sd,\n                               IQR=IQR) ,\n                      na.rm=TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmysum |>\n  tidyr::pivot_longer(\n    cols=everything(), \n    names_pattern = \"(\\\\w+)_([a-z]+)\",\n    names_to= c(\"variable\", \"stat\"), \n    values_to=\"value\") |>\n  head(20) |>\n  gt::gt() |>\n  gt::fmt_number(columns=\"value\", decimals=2)\n```\n\n::: {.cell-output-display}\n\\begingroup\n\\fontsize{12.0pt}{14.4pt}\\selectfont\n\\begin{longtable}{llr}\n\\toprule\nvariable & stat & value \\\\ \n\\midrule\\addlinespace[2.5pt]\nyear & median & 2,013.00 \\\\ \nyear & mean & 2,013.00 \\\\ \nyear & max & 2,013.00 \\\\ \nyear & min & 2,013.00 \\\\ \nyear & sd & 0.00 \\\\ \nNA & NA & 0.00 \\\\ \nmonth & median & 7.00 \\\\ \nmonth & mean & 6.55 \\\\ \nmonth & max & 12.00 \\\\ \nmonth & min & 1.00 \\\\ \nmonth & sd & 3.41 \\\\ \nNA & NA & 6.00 \\\\ \nday & median & 16.00 \\\\ \nday & mean & 15.71 \\\\ \nday & max & 31.00 \\\\ \nday & min & 1.00 \\\\ \nday & sd & 8.77 \\\\ \nNA & NA & 15.00 \\\\ \ndep\\_time & median & 1,401.00 \\\\ \ndep\\_time & mean & 1,349.11 \\\\ \n\\bottomrule\n\\end{longtable}\n\\endgroup\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nCompute a new `itinerary` column concatenating the `origin` and `dest` one.\n\nHave a look at Section [Operate on a selection of variables](https://dplyr.tidyverse.org/reference/scoped.html?q=funs#arguments)\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |>\n  dplyr::mutate(itinerary=paste(dest, origin, sep=\"-\")) |>\n  dplyr::select(itinerary, dest, origin, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 x 20\n   itinerary dest  origin  year month   day dep_time sched_dep_time dep_delay\n   <chr>     <chr> <chr>  <int> <int> <int>    <int>          <int>     <dbl>\n 1 IAH-EWR   IAH   EWR     2013     1     1      517            515         2\n 2 IAH-LGA   IAH   LGA     2013     1     1      533            529         4\n 3 MIA-JFK   MIA   JFK     2013     1     1      542            540         2\n 4 BQN-JFK   BQN   JFK     2013     1     1      544            545        -1\n 5 ATL-LGA   ATL   LGA     2013     1     1      554            600        -6\n 6 ORD-EWR   ORD   EWR     2013     1     1      554            558        -4\n 7 FLL-EWR   FLL   EWR     2013     1     1      555            600        -5\n 8 IAD-LGA   IAD   LGA     2013     1     1      557            600        -3\n 9 MCO-JFK   MCO   JFK     2013     1     1      557            600        -3\n10 ORD-LGA   ORD   LGA     2013     1     1      558            600        -2\n# i 336,766 more rows\n# i 11 more variables: arr_time <int>, sched_arr_time <int>, arr_delay <dbl>,\n#   carrier <chr>, flight <int>, tailnum <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nCompute the coefficient of variation (ratio between the standard deviation and the mean) for each itinerary. Can you find several ways?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |>\n  dplyr::mutate(itinerary=paste(dest, origin, sep=\"-\")) |>\n  dplyr::select(itinerary, dest, origin, everything()) |> \n  dplyr::group_by(itinerary) |> \n  dplyr::summarise(coef_var=sd(air_time, na.rm=T)/mean(air_time, na.rm=T), .groups = \"drop\") |> \n  slice_sample(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n   itinerary coef_var\n   <chr>        <dbl>\n 1 ORF-JFK     0.0899\n 2 JAX-LGA     0.0829\n 3 MVY-JFK     0.0777\n 4 ORF-LGA     0.107 \n 5 MSY-EWR     0.0869\n 6 SBN-EWR     0.0283\n 7 IAD-JFK     0.113 \n 8 CAK-LGA     0.0747\n 9 CLE-EWR     0.0875\n10 PBI-LGA     0.0774\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nCompute for each flight the ratio between the `distance` and the `air_time` in  different ways and compare the execution time (use `Sys.time()`).\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbefore <- Sys.time()\n\ndata |>\n  dplyr::mutate(itinerary=paste(dest, origin, sep=\"-\")) |>\n  dplyr::group_by(itinerary) |>\n  dplyr::summarize(ratio=mean(air_time)/max(distance)) |>\n  dplyr::arrange(desc(ratio))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 x 2\n   itinerary ratio\n   <chr>     <dbl>\n 1 BWI-LGA   0.219\n 2 MEM-JFK   0.172\n 3 MYR-LGA   0.166\n 4 CAE-LGA   0.164\n 5 AVL-LGA   0.154\n 6 LEX-LGA   0.149\n 7 SBN-LGA   0.149\n 8 SBN-EWR   0.147\n 9 JAC-JFK   0.145\n10 STL-JFK   0.145\n# i 214 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nrequired_time <- Sys.time() - before\nrequired_time\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.2207775 secs\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nWhich carrier suffers the most delay?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"} \n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |>\n  dplyr::select(carrier, arr_delay) |>\n  dplyr::filter(arr_delay > 0) |>\n  dplyr::group_by(carrier) |>\n  dplyr::summarise(ndelays= n()) |>\n#  dplyr::arrange(desc(ndelays)) |>\n#  head(3)\n  dplyr::top_n(3, ndelays)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  carrier ndelays\n  <chr>     <int>\n1 B6        23609\n2 EV        24484\n3 UA        22222\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n### Puzzle\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyear <- 2012L\n\ndata |>\n  dplyr::select(year, dest, origin) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n   year dest  origin\n  <int> <chr> <chr> \n1  2013 IAH   EWR   \n2  2013 IAH   LGA   \n3  2013 MIA   JFK   \n4  2013 BQN   JFK   \n5  2013 ATL   LGA   \n6  2013 ORD   EWR   \n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::filter(year==year) |>\n  dplyr::summarize(n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n   `n()`\n   <int>\n1 336776\n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::filter(year==2012L) |>\n  dplyr::summarize(n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n  `n()`\n  <int>\n1     0\n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::filter(year==.env$year) |>\n  dplyr::summarize(n()) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n  `n()`\n  <int>\n1     0\n```\n\n\n:::\n\n```{.r .cell-code}\ndata |>\n  dplyr::filter(year==.data$year) |>\n  dplyr::summarize(n()) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n   `n()`\n   <int>\n1 336776\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\nCan you explain what happens?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\nWhen `dplyr::filter(year==year) ` does `year` refer to the column of `data` or to the variable in the global environment?  \n\n:::::\n\n:::\n\n# Flow control\n\n\n`R` offers the usual flow control constructs:\n\n- branching/alternative  `if (...) {...} else {...}`\n- iterations (while/for) `while (...) {...}` `for (it in iterable) {...}`\n- function calling  `callable(...)` (how do we pass arguments? how do we rely on defaults?)\n\n## `If () then {} else {}`\n\n\nIf expressions `yes_expr` and `no_expr`  are complicated it makes\nsense to use the `if (...) {...} else {...}` construct\n\n\nThere is also a conditional statement with an optional `else {}`\n\n```{.r}\n#| label: if-else\n#| eval: false\n#| collapse: false\nif (condition) {\n  ...\n} else {\n  ...\n}\n```\n\n::: {.callout-note title=\"Question\"}\n\nIs there an `elif` construct in `R`?\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\nNope! \n\n:::\n\n{{< fa hand-point-right >}} `R` also offers a `switch`\n\n```{.r}\n#| label: switch\nswitch (object,\n  case1 = {action1}, \n  case2 = {action2}, \n  ...\n)\n```\n\n::: {.callout-note}\n\nThere exists a selection function `ifelse(test, yes_expr, no_expr)`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nifelse(test, yes, no)\n```\n:::\n\n\n\n\n\n\nNote that `ifelse(...)` is vectorized.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <-  1L:6L\ny <-  rep(\"odd\", 6)\nz <- rep(\"even\", 6)\n\nifelse(x %% 2L, y, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n{{< fa hand-point-right >}} This is a vectorized function\n\n:::\n\n\n\n## Iterations `for (it in iterable) {...}`\n\nHave a look at [Iteration section in R for Data Science](https://r4ds.had.co.nz/iteration.html)\n\n::: {.callout-note title=\"Question\"}\n\n\nCreate a lower triangular matrix which represents the 5 first lines of the Pascal triangle.\n\n\n:::\n\nRecall\n\n$$\\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$$\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT <- matrix(0L, nrow=6, ncol=6)\nT[1,1] <- 1L\n\nfor (i in 2:ncol(T))\n  T[i, 1:i] <- c(0L, T[i-1, 2:i-1]) + T[i-1, 1:i]\n\ncolnames(T) <- 0L:5L\nrownames(T) <- 0L:5L\n\nT\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  0 1  2  3 4 5\n0 1 0  0  0 0 0\n1 1 1  0  0 0 0\n2 1 2  1  0 0 0\n3 1 3  3  1 0 0\n4 1 4  6  4 1 0\n5 1 5 10 10 5 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nLocate the smallest element in a numerical vector\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- sample(1:100, 100)\nv[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 48 91 26 39 59 81 98 24 17 33\n```\n\n\n:::\n\n```{.r .cell-code}\npmin <- 1\n\n# q: what is the purpose of the following loop?\n# for (i in 2:length(v)) {\n#   if (v[i]<v[pmin]) {\n#     pmin <- i\n#   }\n# }\nfor (i in seq_along(v)) {\n  if (v[i]<v[pmin]) {\n    pmin <- i\n  }\n}\n\nprint(stringr::str_c('minimum is at ', pmin, ', it is equal to ', v[pmin]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"minimum is at 37, it is equal to 1\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere are some redundant braces `{}`\n:::::\n\n:::\n\n\n\n## While (condition) {...}\n\n::: {.callout-note title=\"Question\"}\n\nFind the location of the minimum in a vector `v`\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- sample(100, 100)\n\npmin <- 1   # Minimum in v[1:1]\ni <- 2\n\n# q: find le location of the minimum in  vector v\n\nwhile (i <= length(v)) {\n  # loop invariant: v[pmin] == min(v[1:i])\n  if (v[i]<v[pmin]) {\n    pmin <- i\n  }\n  i <- i + 1\n}\n\nprint(stringr::str_c('minimum is at ', pmin, ', it is equal to ', v[pmin]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"minimum is at 48, it is equal to 1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich.min(v); v[which.min(v)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 48\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nWrite a loop that checks whether vector `v` is non-decreasing.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- TRUE\n\nfor (i in 2:length(v))\n  if (v[i] < v[i-1]) {\n    result <- FALSE\n    break\n  }\n\nif (result) {\n  print(\"non-decreasing\")\n} else {\n  print(\"not non-decreasing\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"not non-decreasing\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n\n# Functions\n\nTo define a function, whether named or not, you can use the `function` constructor.  \n\n```{.r}\nfoo <- function(arg1, arg2=def2) {\n  # body\n\n}\n```\n\n::: {.callout-note}\n\n### Question \n\nWrite a function that checks whether vector `v` is non-decreasing.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_non_decreasing <- function(v) {\n  for (i in 2:length(v))\n    if (v[i] < v[i-1]) {\n      return(FALSE)\n    }\n  return(TRUE)\n}\n\nis_non_decreasing(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_non_decreasing(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nA function is an object like any other\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_non_decreasing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction(v) {\n  for (i in 2:length(v))\n    if (v[i] < v[i-1]) {\n      return(FALSE)\n    }\n  return(TRUE)\n}\n<bytecode: 0x5bfd12d2e800>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbody(is_non_decreasing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{\n    for (i in 2:length(v)) if (v[i] < v[i - 1]) {\n        return(FALSE)\n    }\n    return(TRUE)\n}\n```\n\n\n:::\n\n```{.r .cell-code}\nargs(is_non_decreasing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (v) \nNULL\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Question\n\nWrite a function with integer parameter $n$, that returns the Pascal Triangle with $n+1$ rows.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntriangle_pascal <- function(n) {\n  m <- n+1\n  T <- matrix(c(rep(1, m), rep(0, m*(m-1))), nrow=m, ncol=m)\n\n  for (i in 2:m)\n    T[i, 2:i] <- T[i-1, 1:i-1] + T[i-1, 2:i]\n\n  for (i in 1:(m-1))\n    T[i, (i+1):m] <- NA\n\n  colnames(T) <- 0:n\n  rownames(T) <- 0:n\n\n  T\n}\n\nprint(triangle_pascal(10), na.print=\" \" )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   0  1  2   3   4   5   6   7  8  9 10\n0  1                                   \n1  1  1                                \n2  1  2  1                             \n3  1  3  3   1                         \n4  1  4  6   4   1                     \n5  1  5 10  10   5   1                 \n6  1  6 15  20  15   6   1             \n7  1  7 21  35  35  21   7   1         \n8  1  8 28  56  70  56  28   8  1      \n9  1  9 36  84 126 126  84  36  9  1   \n10 1 10 45 120 210 252 210 120 45 10  1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nSanity check: `R` provides us with function `choose`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\nmap(0:n, ~ choose(., 0:.))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1 1\n\n[[3]]\n[1] 1 2 1\n\n[[4]]\n[1] 1 3 3 1\n\n[[5]]\n[1] 1 4 6 4 1\n\n[[6]]\n[1]  1  5 10 10  5  1\n```\n\n\n:::\n\n```{.r .cell-code}\nt10 <- triangle_pascal(10)\n\nfor (n in 0:10)\n  for (p in 0:n)\n    stopifnot(t10[as.character(n), as.character(p)] == choose(n, p))\n```\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question \n\nHow would you generate a Fibonacci sequence of length $n$ ?\n\n:::\n\nRecall the Fibonacci sequence is defined by\n\n$$F_{n+2} = F_{n+1} + F_n \\qquad F_1= F_2 = 1$$\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfibo <- function(n) {\n  res <- integer(n)\n  res[1:2] <- 1\n  for (k in 3:n) {\n    res[k] <- res[k-1] + res[k-2]\n  } \n  return(res)\n}\n\nfibo(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 3 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nWrite a function that perform binary search in a non-decreasing vector.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbinary_search <- function(v, x) {\n  n <- length(v)\n  i <- 1\n  j <- n\n  while (i <= j) {\n    k <- (i+j) %/% 2\n    if (v[k] == x) {\n      return(k)\n    } else if (v[k] < x) {\n      i <- k + 1\n    } else {\n      j <- k - 1\n    }\n  }\n  return(NA)\n}\n```\n:::\n\n\n\n\n\n\n> The provided code defines a function binary_search in R, which implements the binary search algorithm to find the position of a target value x within a sorted vector v. The binary search algorithm is efficient, operating in O(log n) time complexity, making it suitable for large datasets.\n>\n> The function begins by determining the length of the vector v and storing it in the variable n. It then initializes two variables, i and j, to represent the lower and upper bounds of the search range, respectively. Initially, i is set to 1 (the first index of the vector), and j is set to n (the last index of the vector).\n\n> The core of the function is a while loop that continues as long as i is less than or equal to j. Within\nthe loop, the midpoint k of the current search range is calculated using integer division (%/%) to ensure it is an integer. The value at index k in the vector v is then compared to the target value x.\n\n> If the value at v[k] is equal to x, the function returns k, indicating that the target value has been found at this position. If v[k] is less than x, the search range is adjusted by setting i to k + 1, effectively discarding the lower half of the current range. Conversely, if v[k] is greater than x, the search range is adjusted by setting j to k - 1, discarding the upper half of the current range.\n\n> If the loop completes without finding the target value, the function returns NA, indicating that the target value x is not present in the vector v. This implementation assumes that the input vector v is sorted in ascending order.\n\n{{< fa hand-point-right >}} Code and explanation provided by [https://www.techiedelight.com/binary-search-in-r/](https://www.techiedelight.com/binary-search-in-r/)\nthrough copilot\n\n:::::\n\n:::\n\n\n::: {.callout-important}\n\n### {{< fa brain >}}\n\nRead [Chapter on functions in Advanced R](https://adv-r.hadley.nz/functions.html)\n\nIn `R`, argument evalution is surprising, powerful but taming argument evaluation is real work.\n\n:::\n\n\n# Functional programming\n\nIn `R`, functions are first class entities, they can be defined at run-time, they can be used as function arguments. You can define list of functions, and iterate over them.\n\nTry to use [https://purrr.tidyverse.org](https://purrr.tidyverse.org).\n\n::: {.callout-important}\n\n### Anonymous functions \n\n```{.r}\n\\(x) body\n```\nis a shorthand for\n\n```{.r}\nfunction (x) {\n  body\n}\n```\n\n:::\n\n\n## Operators `purrr::map_???`\n\n::: {.callout-note}\n\n### Question\n\nWrite truth tables for `&, |, &&, ||, !` and `xor`\n\n*Hint*: use `purrr::map`, function `outer()`\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvals <- c(TRUE, FALSE, NA)\nops <- c(`&`, `|`, `xor`)\n\ntruth <- purrr::map(ops, \\(x) outer(vals,vals, x))\n\nnames(truth) <- (ops)\ntruth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`.Primitive(\"&\")`\n      [,1]  [,2]  [,3]\n[1,]  TRUE FALSE    NA\n[2,] FALSE FALSE FALSE\n[3,]    NA FALSE    NA\n\n$`.Primitive(\"|\")`\n     [,1]  [,2] [,3]\n[1,] TRUE  TRUE TRUE\n[2,] TRUE FALSE   NA\n[3,] TRUE    NA   NA\n\n$`function (x, y) \\n{\\n    (x | y) & !(x & y)\\n}`\n      [,1]  [,2] [,3]\n[1,] FALSE  TRUE   NA\n[2,]  TRUE FALSE   NA\n[3,]    NA    NA   NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nWrite a function that takes as input a square matrix\nand returns `TRUE` if it is lower triangular.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlt <- function(A){\n  n <- nrow(A)\n  all(purrr::map_lgl(1:(n-1), \\(x) all(0 == A[x, (x+1):n])))\n}\n```\n:::\n\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nUse `map` , `choose` and proper use of pronouns to deliver the\n`n` first lines of the Pascal triangle using one line of code.\n\nAs far as the total number of operations is concerned, would you recommend\nthis way of computing the Pascal triangle?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout title=\"Solution\" collapse=\"false\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\n\ntp5 <- matrix(unlist(map(0:n,\n           \\(x) c(choose(x, 0:x), rep(0L, n-x)))),\n       nrow=n+1,\n       byrow=T)\n\nrownames(tp5) <- 0:n\n\ncolnames(tp5) <- 0:n\n\ntp5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  0 1  2  3 4 5\n0 1 0  0  0 0 0\n1 1 1  0  0 0 0\n2 1 2  1  0 0 0\n3 1 3  3  1 0 0\n4 1 4  6  4 1 0\n5 1 5 10 10 5 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNo. Using `map`  and `choose`, we do not reuse previous computations.\nThe total number of arithmetic operations is $\\Omega(n^3)$, it should be\n$O(n^2)$.\n\n:::::\n\n:::\n\n\n::: {.callout-important}\n\nRead [Chapter on Functional Programming in Advanced R](https://adv-r.hadley.nz/fp.html)\n\n:::\n\n\n# Further exploration\n\nThis notebook walked you through some aspects of `R` and its packages. We just saw the tip of the iceberg.\n\nWe barely mentioned:\n\n- (Non-standard) Lazy evaluation\n- Different flavors of object oriented programming\n- Connection with `C++`: `RCpp`\n- Connection with databases: `dbplyr`\n- Building modeling pipelines: `tidymodels`\n- Concurrency\n- Building packages\n- Building interactive Apps: `Shiny`\n- Attributes (metadata)\n- Formulae  `formula`\n- Strings  `stringi`, `stringr`\n- Dates `lubridate`\n- and plenty other things  ....\n\n\n# References\n\n- [https://www.statmethods.net/index.html](https://www.statmethods.net/index.html)\n- [https://www.datacamp.com/courses/free-introduction-to-r](https://www.datacamp.com/courses/free-introduction-to-r)\n- [dplyr videos](https://www.youtube.com/hashtag/dplyr) \n- [ggplot2 video tutorial](https://www.youtube.com/hashtag/ggplot2) \n- [cheatsheets](https://posit.co/resources/cheatsheets/)\n\n\n::: {.callout-warning}\n\nReaders who really want to learn `R` should spend time on \n\n- [R for Data Science](https://r4ds.hadley.nz) by Wickham, √áetinkaya-Rundel, and Grolemund.\n- [Advanced R 2nd Edition](https://adv-r.hadley.nz) by Wickham\n- [Advanced R Solutions](https://advanced-r-solutions.rbind.io) by Grosser and Bumann\n- [Hands-On Programming with R](https://rstudio-education.github.io/hopr) by Grolemund\n\n\nDon't go without [Base R cheatsheet](https://rstudio.github.io/cheatsheets/base-r.pdf)\n\n:::\n",
    "supporting": [
      "lab-R-introd_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\n\\usepackage{caption}\n\\usepackage{longtable}\n\\usepackage{colortbl}\n\\usepackage{array}\n\\usepackage{anyfontsize}\n\\usepackage{multirow}\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}