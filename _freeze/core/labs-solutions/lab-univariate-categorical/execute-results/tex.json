{
  "hash": "29fcecad909dd0e773239c71c85f2a09",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Univariate Categorical Analysis'\ndate: \"2025-03-18 15:20:47.625319\"\n\n\nexecute:\n  echo: true\n  eval: true\n  collapse: true\n\n\n\nformat:\n  html:\n    output-file: lab-univariate-categorical.html\n  pdf:\n    output-file: lab-univariate-categorical.pdf\n\nengine: knitr\n\n---\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| Ann√©e {{< var year >}}     |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n::: {.callout-important}\n\n### Objectives\n\nIn Exploratory analysis of tabular data, univariate analysis is the first step. It consists in exploring, summarizing, visualizing columns of a dataset.\n\nIn this Lab, we describe univariate categorical analysis\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n\nTry to load (potentially) useful packages in a chunk at the beginning of your file.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nto_be_loaded <- c(\n  \"tidyverse\", \n  \"lobstr\", \n  \"ggforce\",\n  \"patchwork\", \n  \"glue\",\n  \"magrittr\",\n  \"gt\",\n  \"DT\", \n  \"lobstr\",\n  \"kableExtra\",\n  \"viridis\"\n)\n\npurrr::map_lgl(\n  to_be_loaded,\n  \\(x) require(x,\n    character.only = T,\n    quietly = T)\n  )\n##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n:::\n\n\n\n\n\n\nSet the (graphical) theme\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_theme <- theme_set(theme_minimal())\n```\n:::\n\n\n\n\n\n\n:::\n\n\n::: {.callout-tip}\n\nIn this lab, we load the data from the hard drive. The data are read from some file located \nin our tree of directories. Loading requires the determination of the correct filepath. \nThis filepath is often a *relative filepath*, it is relative to the directory where the `R` session/the `R` script has been launched. Base `R` offers functions that can help you to find your way the directories tree. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd() # Where are we? \n## [1] \"/home/boucheron/Documents/MA7BY020/core/labs-solutions\"\nhead(list.files())  # List the files in the current directory\n## [1] \"_metadata.yml\"       \"_preamble.qmd\"       \"DATA\"               \n## [4] \"lab-bivariate_cache\" \"lab-bivariate_files\" \"lab-bivariate.qmd\"\nhead(list.dirs())   # List sub-directories\n## [1] \".\"                          \"./DATA\"                    \n## [3] \"./lab-bivariate_cache\"      \"./lab-bivariate_cache/html\"\n## [5] \"./lab-bivariate_cache/pdf\"  \"./lab-bivariate_files\"\n```\n:::\n\n\n\n\n\n\n{{< fa hand-point-right >}} Package `here` for navigating the working tree.\n\n:::\n\n\n# Objectives\n\nIn this lab, we introduce univariate analysis for *categorical* variables.\n\nThis amounts to exploring, summarizing, visualizing *categorical* columns of a dataset.\n\nThis also often involves table wrangling: retyping some columns, relabelling, reordering, lumping levels of *factors*, that is factor re-engineering. \n\nSummarizing univariate categorical samples amounts to counting the number of occurrences of levels in the sample. \n\nVisualizing categorical samples starts with\n\n- `Bar plots`\n- `Column plots`\n\nThis exploratory work seldom makes it to the final report. Nevertheless, it has to be done in an efficient, reproducible way. \n\nThis is an opportunity to revisit the DRY principle. \n\nAt the end, we shall see that `skimr::skim()` can be very helpful. \n\n# Dataset  Recensement \n\nHave a look at the text file. Choose a loading function \nfor each format. `Rstudio` IDE provides a valuable helper. \n\nLoad the data into the session environment and call it `df`.\n\n::: {.callout-note}\n\n### Question\n\nCreate if it does not already exist, a subdirectory `DATA` in your working directory. \n\n:::\n\n::: {.callout-tip}\n\nThe `fs` package contains a number of useful functions for handling files and directories with a consistent API. \n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip  title=\"Solution\"}\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!fs::dir_exists('./DATA')) {\n  warning(glue::glue(\"Creating directory ./DATA in {getwd()}\"))\n  fs::dir_create('./DATA')\n}\n```\n:::\n\n\n\n\n\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nDownload file `Recensement` from URL `https://stephane-v-boucheron.fr/data/Recensement.csv`.  Base function `download.file()` is enough.\n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!fs::file_exists(\"./DATA/Recensement.csv\")) {\n  warning(\"Downloading Recensement.csv from  https://stephane-v-boucheron.fr/data/Recensement.csv\")\n  download.file('https://stephane-v-boucheron.fr/data/Recensement.csv', \n                \"./DATA/Recensement.csv\")\n  warning(\"Downloaded!!\")\n}\n\ndf <- readr::read_table(\"./DATA/Recensement.csv\")\n\ndf %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 599\nColumns: 11\n$ AGE        <dbl> 58, 40, 29, 59, 51, 19, 64, 23, 47, 66, 26, 23, 54, 44, 56,~\n$ SEXE       <chr> \"F\", \"M\", \"M\", \"M\", \"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"F\",~\n$ REGION     <chr> \"NE\", \"W\", \"S\", \"NE\", \"W\", \"NW\", \"S\", \"NE\", \"NW\", \"S\", \"NE\"~\n$ STAT_MARI  <chr> \"C\", \"M\", \"C\", \"D\", \"M\", \"C\", \"M\", \"C\", \"M\", \"D\", \"M\", \"C\",~\n$ SAL_HOR    <dbl> 13.25, 12.50, 14.00, 10.60, 13.00, 7.00, 19.57, 13.00, 20.1~\n$ SYNDICAT   <chr> \"non\", \"non\", \"non\", \"oui\", \"non\", \"non\", \"non\", \"non\", \"ou~\n$ CATEGORIE  <dbl> 5, 7, 5, 3, 3, 3, 9, 1, 8, 5, 2, 5, 3, 2, 2, 2, 5, 9, 2, 2,~\n$ NIV_ETUDES <dbl> 43, 38, 42, 39, 35, 39, 40, 43, 40, 40, 42, 40, 34, 40, 43,~\n$ NB_PERS    <dbl> 2, 2, 2, 4, 8, 6, 3, 2, 3, 1, 3, 2, 6, 5, 4, 4, 3, 2, 3, 2,~\n$ NB_ENF     <dbl> 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,~\n$ REV_FOYER  <dbl> 11, 7, 15, 7, 15, 16, 13, 11, 12, 8, 10, 8, 13, 11, 14, 7, ~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHave a glimpse at the dataframe\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  glimpse()\n## Rows: 599\n## Columns: 11\n## $ AGE        <dbl> 58, 40, 29, 59, 51, 19, 64, 23, 47, 66, 26, 23, 54, 44, 56,~\n## $ SEXE       <chr> \"F\", \"M\", \"M\", \"M\", \"M\", \"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"F\",~\n## $ REGION     <chr> \"NE\", \"W\", \"S\", \"NE\", \"W\", \"NW\", \"S\", \"NE\", \"NW\", \"S\", \"NE\"~\n## $ STAT_MARI  <chr> \"C\", \"M\", \"C\", \"D\", \"M\", \"C\", \"M\", \"C\", \"M\", \"D\", \"M\", \"C\",~\n## $ SAL_HOR    <dbl> 13.25, 12.50, 14.00, 10.60, 13.00, 7.00, 19.57, 13.00, 20.1~\n## $ SYNDICAT   <chr> \"non\", \"non\", \"non\", \"oui\", \"non\", \"non\", \"non\", \"non\", \"ou~\n## $ CATEGORIE  <dbl> 5, 7, 5, 3, 3, 3, 9, 1, 8, 5, 2, 5, 3, 2, 2, 2, 5, 9, 2, 2,~\n## $ NIV_ETUDES <dbl> 43, 38, 42, 39, 35, 39, 40, 43, 40, 40, 42, 40, 34, 40, 43,~\n## $ NB_PERS    <dbl> 2, 2, 2, 4, 8, 6, 3, 2, 3, 1, 3, 2, 6, 5, 4, 4, 3, 2, 3, 2,~\n## $ NB_ENF     <dbl> 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,~\n## $ REV_FOYER  <dbl> 11, 7, 15, 7, 15, 16, 13, 11, 12, 8, 10, 8, 13, 11, 14, 7, ~\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n# Column (re)coding\n\n\nIn order to understand the role of each column, have a look at the following coding tables.\n\n- `SEXE`\n  + F: Female\n  + M: Male\n- `REGION`\n  + NE: North-East\n  + W: West\n  + S: South\n  + NW: North-West\n- `STAT_MARI`\n  + C  (Unmarried) \n  + M  (Married)\n  + D  (Divorced)\n  + S  (Separated)\n  + V  (Widowed)\n- `SYNDICAT`:\n  + \"non\": not affiliated with any Labour Union\n  + \"oui\": affiliated with a Labour Union\n- `CATEGORIE`: Professional activity\n  + 1: Business, Management and Finance\n  + 2: Liberal professions\n  + 3: Services\n  + 4: Selling\n  + 5: Administration\n  + 6: Agriculture, Fishing, Forestry\n  + 7: Building\n  + 8: Repair and maintenance\n  + 9: Production\n  + 10: Commodities Transportation\n- `NIV_ETUDES`: Education level\n  + 32: at most 4 years schooling\n  + 33: between 5 and 6 years schooling\n  + 34: between 7 and 8 years schooling\n  + 35: 9 years schooling\n  + 36: 10 years schooling\n  + 37: 11 years schooling\n  + 38: 12 years schooling, dropping out from High School without a diploma\n  + 39: 12 years schooling, with High School diploma\n  + 40: College education with no diploma\n  + 41: [Associate degree](https://en.wikipedia.org/wiki/Associate_degree), vocational.  Earned in two years or more\n  + 42: [Associate degree](https://en.wikipedia.org/wiki/Associate_degree), academic. Earned in two years or more\n  + 43: [Bachelor](https://en.wikipedia.org/wiki/Bachelor%27s_degree)\n  + 44: [Master](https://en.wikipedia.org/wiki/Master%27s_degree)\n  + 45: Specific School Diploma\n  + 46: [PhD](https://en.wikipedia.org/wiki/Doctor_of_Philosophy)\n- `REV_FOYER` : Classes of annual household income in dollars.\n- `NB_PERS` : Number of people in the household.\n- `NB_ENF` : Number of children in the household.\n\n# Handling factors\n\n\nWe build lookup tables to incorporate the above information.\nIn `R`, named vectors are convenient.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncategory_lookup = c(\n  \"1\"= \"Business, Management and Finance\",\n  \"2\"= \"Liberal profession\",\n  \"3\"= \"Services\",\n  \"4\"= \"Selling\",\n  \"5\"= \"Administration\",\n  \"6\"= \"Agriculture, Fishing, Forestry\",\n  \"7\"= \"Building \",\n  \"8\"= \"Repair and maintenance\",\n  \"9\"= \"Production\",\n  \"10\"= \"Commodities Transport\"\n)\n\n# code_category <- as_tibble() %>% rownames_to_column() %>% rename(code = rowname, name=value)\n```\n:::\n\n\n\n\n\n\nIn the next chunk, the named vectors are turned into two-columns dataframes (tibbles).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nvector2tibble <- function(v) { \n  tibble(name=v, code= names(v))\n} \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncode_category <- category_lookup %>%\n  vector2tibble()\n\ncode_category\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n   name                               code \n   <chr>                              <chr>\n 1 \"Business, Management and Finance\" 1    \n 2 \"Liberal profession\"               2    \n 3 \"Services\"                         3    \n 4 \"Selling\"                          4    \n 5 \"Administration\"                   5    \n 6 \"Agriculture, Fishing, Forestry\"   6    \n 7 \"Building \"                        7    \n 8 \"Repair and maintenance\"           8    \n 9 \"Production\"                       9    \n10 \"Commodities Transport\"            10   \n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n\nUsing the `magrittr` pipe `%>%`, the function `vector2tibble` could have been defined using the  concise piping notation. Then `.` serves as a *pronoun*.  \n\n```{.r}\nvector2tibble <- . %>% \n  tibble(name=., code= names(.))  # The lhs of the pipe is used twice.\n```\n\n\nNote the use of `.` as pronoun for the function argument. \n\nThis construction is useful for turning a pipeline into a univariate function. \n\n\nThe function `vector2tibble` could also be defined by binding \nidentifier `vector2tibble` with an *anonymous function*. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector2tibble <- \\(v) tibble(name=v, code= names(v)) \n```\n:::\n\n\n\n\n\n\n\n:::\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\neducation_lookup = c(\n  \"32\"= \"<= 4 years schooling\",\n  \"33\"= \"between 5 and 6 years\",\n  \"34\"= \"between 7 and 8 years\",\n  \"35\"= \"9 years schooling\",\n  \"36\"= \"10 years schooling\",\n  \"37\"= \"11 years schooling\",\n  \"38\"= \"12 years schooling, no diploma\",\n  \"39\"= \"12 years schooling, HS diploma\",\n  \"40\"= \"College without diploma\",\n  \"41\"= \"Associate degree, vocational\",\n  \"42\"= \"Associate degree, academic\",\n  \"43\"= \"Bachelor\",\n  \"44\"= \"Master\",\n  \"45\"= \"Specific School Diploma\",\n  \"46\"= \"PhD\"\n)\n\ncode_education <- vector2tibble(education_lookup)\n  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstatus_lookup <- c(\n  \"C\"=\"Single\", \n  \"M\"=\"Maried\",\n  \"V\"=\"Widowed\",\n  \"D\"=\"Divorced\",\n  \"S\"=\"Separated\"\n)\n\ncode_status <- status_lookup %>% \n  vector2tibble()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbreaks_revenue <-c(\n  0,\n  5000,  \n  7500, \n  10000, \n  12500, \n  15000, \n  17500, \n  20000,\n  25000, \n  30000, \n  35000, \n  40000,\n  50000, \n  60000, \n  75000, \n  100000, \n  150000\n)\n```\n:::\n\n\n\n\n\n\n# Table wrangling\n\n::: {.callout-note title=\"Question\"}\n\nWhich columns should be considered as categorical/factor?\n\n:::\n\n::: {.callout-tip collapse=\"false\"}\n\nDeciding which variables are categorical sometimes requires judgement. \n\nLet us attempt to base the decision on a checkable criterion: determine \nthe number of distinct values in each column, consider those columns with less \nthan 20 distinct values as factors. \n\nWe can find the names of the columns with few unique values by iterating over the column names.\n\n:::\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\nWe already designed a pipeline to determine which columns should be transformed \ninto a `factor` (categorized). In the next chunk, we turn the pipeline into a univariate function\nnamed  `to_be_categorized` with one argument (the dataframe) \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_be_categorized  <- . %>% \n  summarise(across(everything(), n_distinct)) %>% \n  pivot_longer(cols = everything(), values_to = c(\"n_levels\")) %>% \n  filter(n_levels < 20) %>% \n  arrange(n_levels) %>% \n  pull(name)\n```\n:::\n\n\n\n\n\n\n`to_be_categorized` can be used like a function.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_be_categorized\n## Functional sequence with the following components:\n## \n##  1. summarise(., across(everything(), n_distinct))\n##  2. pivot_longer(., cols = everything(), values_to = c(\"n_levels\"))\n##  3. filter(., n_levels < 20)\n##  4. arrange(., n_levels)\n##  5. pull(., name)\n## \n## Use 'functions' to extract the individual functions.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntbc <- to_be_categorized(df)\n\ntbc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SEXE\"       \"SYNDICAT\"   \"REGION\"     \"STAT_MARI\"  \"NB_ENF\"    \n[6] \"NB_PERS\"    \"CATEGORIE\"  \"NIV_ETUDES\" \"REV_FOYER\" \n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n::: {.callout-note}\n\nNote that columns `NB_PERS` and `NB_ENF` have few unique values and nevertheless we could consider them as quantitative. \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nCoerce the relevant columns as factors. \n\n:::\n\n\n::: {.callout-tip}\n\n\nUse `dplyr` and `forcats` verbs to perform  this coercion. \n\nUse the `across()` construct so as to perform  a kind if *tidy selection* (as with `select`) with verb `mutate`. \n\nYou may use `forcats::as_factor()` to transform columns when needed. \n\nVerb `dplyr::mutate` is a convenient way to modify a dataframe. \n\n:::\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\nWe can repeat the categorization step used in the preceding lab.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(across(all_of(tbc), as_factor)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 599\nColumns: 11\n$ AGE        <dbl> 58, 40, 29, 59, 51, 19, 64, 23, 47, 66, 26, 23, 54, 44, 56,~\n$ SEXE       <fct> F, M, M, M, M, M, F, F, M, F, M, F, F, F, F, F, F, M, M, F,~\n$ REGION     <fct> NE, W, S, NE, W, NW, S, NE, NW, S, NE, NE, W, NW, S, S, NW,~\n$ STAT_MARI  <fct> C, M, C, D, M, C, M, C, M, D, M, C, M, C, M, C, S, M, S, C,~\n$ SAL_HOR    <dbl> 13.25, 12.50, 14.00, 10.60, 13.00, 7.00, 19.57, 13.00, 20.1~\n$ SYNDICAT   <fct> non, non, non, oui, non, non, non, non, oui, non, non, non,~\n$ CATEGORIE  <fct> 5, 7, 5, 3, 3, 3, 9, 1, 8, 5, 2, 5, 3, 2, 2, 2, 5, 9, 2, 2,~\n$ NIV_ETUDES <fct> 43, 38, 42, 39, 35, 39, 40, 43, 40, 40, 42, 40, 34, 40, 43,~\n$ NB_PERS    <fct> 2, 2, 2, 4, 8, 6, 3, 2, 3, 1, 3, 2, 6, 5, 4, 4, 3, 2, 3, 2,~\n$ NB_ENF     <fct> 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,~\n$ REV_FOYER  <fct> 11, 7, 15, 7, 15, 16, 13, 11, 12, 8, 10, 8, 13, 11, 14, 7, ~\n```\n\n\n:::\n:::\n\n\n\n\n\n\n{{< fa hand-point-right >}} What is the meaning of `all_of(tbc)`?\n\n\nThe pronoun mechanism that comes with the pipe `%>%` offers a alternative:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df %>% \n  mutate(across(all_of(to_be_categorized(.)), as_factor)) \n  \ndf  %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 599\nColumns: 11\n$ AGE        <dbl> 58, 40, 29, 59, 51, 19, 64, 23, 47, 66, 26, 23, 54, 44, 56,~\n$ SEXE       <fct> F, M, M, M, M, M, F, F, M, F, M, F, F, F, F, F, F, M, M, F,~\n$ REGION     <fct> NE, W, S, NE, W, NW, S, NE, NW, S, NE, NE, W, NW, S, S, NW,~\n$ STAT_MARI  <fct> C, M, C, D, M, C, M, C, M, D, M, C, M, C, M, C, S, M, S, C,~\n$ SAL_HOR    <dbl> 13.25, 12.50, 14.00, 10.60, 13.00, 7.00, 19.57, 13.00, 20.1~\n$ SYNDICAT   <fct> non, non, non, oui, non, non, non, non, oui, non, non, non,~\n$ CATEGORIE  <fct> 5, 7, 5, 3, 3, 3, 9, 1, 8, 5, 2, 5, 3, 2, 2, 2, 5, 9, 2, 2,~\n$ NIV_ETUDES <fct> 43, 38, 42, 39, 35, 39, 40, 43, 40, 40, 42, 40, 34, 40, 43,~\n$ NB_PERS    <fct> 2, 2, 2, 4, 8, 6, 3, 2, 3, 1, 3, 2, 6, 5, 4, 4, 3, 2, 3, 2,~\n$ NB_ENF     <fct> 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,~\n$ REV_FOYER  <fct> 11, 7, 15, 7, 15, 16, 13, 11, 12, 8, 10, 8, 13, 11, 14, 7, ~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe dot `.` in `all_of(to_be_categorized(.))` refers to the left-hand side of `%>%`. \n\n:::\n\n:::::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\nEvaluation of `pull(to_be_categorized, name)` returns a \ncharacter vector containing the names of the columns to be categorized. `all_of()` enables `mutate` to perform `as_factor()` on  each of these columns and to bind the column names to the transformed columns. \n\n:::\n\n:::::\n\n::: {.callout-note title=\"Question\"}\n\nRelabel the levels of `REV_FOYER` using the breaks.\n\n\n:::\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\nWe first built readable labels for `REV_FOYER`. As each level of `REV_FOYER` corresponds to an interval, we use \nintervals as labels. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nincome_slices <- levels(df$REV_FOYER)\n\nl <- length(breaks_revenue)\n\nnames(income_slices) <- paste(\n  \"[\",\n  breaks_revenue[-l], \n  \"-\", \n  lead(breaks_revenue)[-l], \n  \")\",\n  sep=\"\"\n)\n```\n:::\n\n\n\n\n\n\n{{< fa hand-point-right >}} What does `lead()` do?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df %>% \n  mutate(REV_FOYER=forcats::fct_recode(REV_FOYER, !!!income_slices)) \n\ndf %>% \n  relocate(REV_FOYER) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 11\n  REV_FOYER     AGE SEXE  REGION STAT_MARI SAL_HOR SYNDICAT CATEGORIE NIV_ETUDES\n  <fct>       <dbl> <fct> <fct>  <fct>       <dbl> <fct>    <fct>     <fct>     \n1 [35000-400~    58 F     NE     C            13.2 non      5         43        \n2 [17500-200~    40 M     W      M            12.5 non      7         38        \n3 [75000-1e+~    29 M     S      C            14   non      5         42        \n4 [17500-200~    59 M     NE     D            10.6 oui      3         39        \n5 [75000-1e+~    51 M     W      M            13   non      3         35        \n6 [1e+05-150~    19 M     NW     C             7   non      3         39        \n# i 2 more variables: NB_PERS <fct>, NB_ENF <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\n\nNote the use of `!!!` (bang-bang-bang) to unpack the named vector `income_slices`. The  bang-bang-bang device  is offered by `rlang`, a package from `tidyverse`. It provides a very handy way of calling functions like `fct_recode` that take an unbounded  list of key-values pairs as argument. This is very much like handling keyword arguments in Python using  dictionary unpacking. \n\n:::\n\n:::\n\n:::::\n\nRelabel the levels of the different factors so as to make the data more readbale\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  select(where(is.factor)) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 9\n  SEXE  REGION STAT_MARI SYNDICAT CATEGORIE NIV_ETUDES NB_PERS NB_ENF REV_FOYER \n  <fct> <fct>  <fct>     <fct>    <fct>     <fct>      <fct>   <fct>  <fct>     \n1 F     NE     C         non      5         43         2       0      [35000-40~\n2 M     W      M         non      7         38         2       0      [17500-20~\n3 M     S      C         non      5         42         2       0      [75000-1e~\n4 M     NE     D         oui      3         39         4       1      [17500-20~\n5 M     W      M         non      3         35         8       1      [75000-1e~\n6 M     NW     C         non      3         39         6       0      [1e+05-15~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe columns that call for relabelling the levels are:\n\n- `CATEGORIE`\n- `NIV_ETUDES`\n\n:::\n\n:::::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlookup_category <- code_category$code\nnames(lookup_category) <- code_category$name\n\nlookup_niv_etudes <- code_education$code\nnames(lookup_niv_etudes) <- code_education$name\n\ndf <- df %>% \n  mutate(CATEGORIE=forcats::fct_recode(CATEGORIE, !!!lookup_category)) %>%\n  mutate(NIV_ETUDES=forcats::fct_recode(NIV_ETUDES, !!!lookup_niv_etudes)) \n  \ndf %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 11\n    AGE SEXE  REGION STAT_MARI SAL_HOR SYNDICAT CATEGORIE     NIV_ETUDES NB_PERS\n  <dbl> <fct> <fct>  <fct>       <dbl> <fct>    <fct>         <fct>      <fct>  \n1    58 F     NE     C            13.2 non      \"Administrat~ Bachelor   2      \n2    40 M     W      M            12.5 non      \"Building \"   12 years ~ 2      \n3    29 M     S      C            14   non      \"Administrat~ Associate~ 2      \n4    59 M     NE     D            10.6 oui      \"Services\"    12 years ~ 4      \n5    51 M     W      M            13   non      \"Services\"    9 years s~ 8      \n6    19 M     NW     C             7   non      \"Services\"    12 years ~ 6      \n# i 2 more variables: NB_ENF <fct>, REV_FOYER <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n{{< fa hand-point-right >}} We should be able to DRY this. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TODO\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\n# Search for missing data  (optional)\n\n::: {.callout-note title=\"Question\"}\n\nCheck whether some columns contain missing data (use `is.na`).\n\n:::\n\n::: {.callout-tip}\nUseful functions:\n\n- `dplyr::summarise`\n- `across`\n- `tidyr::pivot_longer`\n- `dplyr::arrange`\n\n:::\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  is.na() %>% \n  as_tibble %>% \n  summarise(across(everything(), sum))  %>%\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n| AGE| SEXE| REGION| STAT_MARI| SAL_HOR| SYNDICAT| CATEGORIE| NIV_ETUDES| NB_PERS| NB_ENF| REV_FOYER|\n|---:|----:|------:|---------:|-------:|--------:|---------:|----------:|-------:|------:|---------:|\n|   0|    0|      0|         0|       0|        0|         0|          0|       0|      0|         0|\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\n# Summarizing categorical data\n\n## Counting\n\n::: {.callout-note title=\"Question\"} \n\nUse `table`, `prop.table` from base `R`  to compute the frequencies and proportions\nof the different levels. In statistics, the result of `table()` is a (one-way) _contingency table_.\n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  pull(REV_FOYER) |>\n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n      [0-5000)    [5000-7500)   [7500-10000)  [10000-12500)  [12500-15000) \n             9              5              5              9              7 \n [15000-17500)  [17500-20000)  [20000-25000)  [25000-30000)  [30000-35000) \n            19             26             38             30             35 \n [35000-40000)  [40000-50000)  [50000-60000)  [60000-75000)  [75000-1e+05) \n            61             70             71             89             77 \n[1e+05-150000) \n            48 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  count(REV_FOYER)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 x 2\n   REV_FOYER          n\n   <fct>          <int>\n 1 [0-5000)           9\n 2 [5000-7500)        5\n 3 [7500-10000)       5\n 4 [10000-12500)      9\n 5 [12500-15000)      7\n 6 [15000-17500)     19\n 7 [17500-20000)     26\n 8 [20000-25000)     38\n 9 [25000-30000)     30\n10 [30000-35000)     35\n11 [35000-40000)     61\n12 [40000-50000)     70\n13 [50000-60000)     71\n14 [60000-75000)     89\n15 [75000-1e+05)     77\n16 [1e+05-150000)    48\n```\n\n\n:::\n:::\n\n\n\n\n\n  \n:::\n\n:::::\n\nWhat is the *class* of the *object* generated by `table`? Is it a `vector`, a `list`, a `matrix`, an `array` ? \n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nta <- df %>% \n  pull(REV_FOYER) %>% \n  table() \n\nl <- list(\n  is.vector=is.vector, \n  is.list=is.list, \n  is.matrix=is.matrix, \n  is.array=is.array\n)\n\nmap_lgl(l, ~ .x(ta))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nis.vector   is.list is.matrix  is.array \n    FALSE     FALSE     FALSE      TRUE \n```\n\n\n:::\n:::\n\n\n\n\n\n  \n:::\n\n:::::\n\n\n::: {.callout-note}\n\n`as.data.frame()` (or `as_tibble`) can transform a `table` object into a dataframe.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nta <-  rename(as.data.frame(ta), REV_FOYER=`.`)\n\nta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        REV_FOYER Freq\n1        [0-5000)    9\n2     [5000-7500)    5\n3    [7500-10000)    5\n4   [10000-12500)    9\n5   [12500-15000)    7\n6   [15000-17500)   19\n7   [17500-20000)   26\n8   [20000-25000)   38\n9   [25000-30000)   30\n10  [30000-35000)   35\n11  [35000-40000)   61\n12  [40000-50000)   70\n13  [50000-60000)   71\n14  [60000-75000)   89\n15  [75000-1e+05)   77\n16 [1e+05-150000)   48\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n\nYou may use `knitr::kabble()`, possibly `knitr::kable(., format=\"markdown\")` to tweak the output.\n\nIf you are more ambitious, use `gt::...`.\n\nIn order to feed `ggplot` with a contingency table, \nit is useful to build contingency tables as dataframes. \nUse `dplyr::count()` to do this. \n\n\n::: {.callout-tip}\n\n`skimr::skim()` allows us to perform univariate categorical analysis all at once.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\ndf %>% \n  skimr::skim(where(is.factor)) %>% \n  print(n=50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n-- Data Summary ------------------------\n                           Values    \nName                       Piped data\nNumber of rows             599       \nNumber of columns          11        \n_______________________              \nColumn type frequency:               \n  factor                   9         \n________________________             \nGroup variables            None      \n\n-- Variable type: factor -------------------------------------------------------\n  skim_variable n_missing complete_rate ordered n_unique\n1 SEXE                  0             1 FALSE          2\n2 REGION                0             1 FALSE          4\n3 STAT_MARI             0             1 FALSE          5\n4 SYNDICAT              0             1 FALSE          2\n5 CATEGORIE             0             1 FALSE         10\n6 NIV_ETUDES            0             1 FALSE         15\n7 NB_PERS               0             1 FALSE          9\n8 NB_ENF                0             1 FALSE          7\n9 REV_FOYER             0             1 FALSE         16\n  top_counts                           \n1 M: 302, F: 297                       \n2 S: 200, W: 148, NE: 129, NW: 122     \n3 M: 325, C: 193, D: 61, S: 14         \n4 non: 496, oui: 103                   \n5 Lib: 133, Ser: 125, Adm: 94, Sel: 48 \n6 12 : 187, Col: 148, Bac: 114, Ass: 45\n7 2: 196, 4: 130, 3: 122, 1: 63        \n8 0: 413, 1: 86, 2: 76, 3: 18          \n9 [60: 89, [75: 77, [50: 71, [40: 70   \n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe output can be tailored to your specific objectives and fed to functions that are geared to displaying large tables\n(see packages `knitr`, `DT`, and `gt`)\n\n:::\n\n# Save the (polished) data\n\nSaving polished data in self-documented formats can be time-saving. \nBase `R` offers the `.RDS` format\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  saveRDS(\"./DATA/Recensement.RDS\")\n```\n:::\n\n\n\n\n\n\nBy saving into this format we can persist our work. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <-  readRDS(\"./DATA/Recensement.RDS\")\n\ndt %>% \n  glimpse()\n```\n:::\n\n\n\n\n\n\nCompare the size of `csv` and `RDS` files.\n\n\n# Plotting\n\nPlot the counts, first for column `SEXE`\n\nWe shall use `barplots` to visualize counts.\n\n*barplot* belongs to the bar graphs family. \n\nBuild a barplot to visualize the distribution of the `SEXE` column. \n\nUse \n\n- `geom_bar` (working directly with the data)\n- `geom_col` (working with a contingency table)\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n  \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  df %>% \n    ggplot() +\n    aes(x=SEXE) +\n    geom_bar() +\n    ggtitle(\"With geom_bar\")) + (\n  df %>% \n    count(SEXE) %>% \n    ggplot() +\n    aes(x=SEXE, y=n) +\n    geom_col() +\n    ggtitle(\"With geom_col\")\n  ) \n```\n\n::: {.cell-output-display}\n![](lab-univariate-categorical_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\nWhen investigating relations between categerical columns we will often rely on `mosaicplot()`. Indeed, `barplot` and `mosaicplot` belong to the collection of area plots that are used to visualize counts (statistical summaries for categorical variables).\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosaicplot(~ SEXE, df)\n```\n\n::: {.cell-output-display}\n![](lab-univariate-categorical_files/figure-pdf/unnamed-chunk-32-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n# Repeat the same operation for each qualitative variable (DRY)\n\n\n## Using a `for` loop\n\n\nWe have to build a barplot for each categorical variable. Here, we just have nine of them. We could do this using cut and paste, and some editing. In doing so, we would not comply with the DRY (Don't Repeat Yourself) principle. \n\nIn order to remain DRY, we will attempt to abstract the recipe we used to build our first barplot. \n\nThis recipe is pretty simple:\n\n1. Build a `ggplot` object with `df` as the data layer.\n2. Add an aesthetic mapping a categorical column to axis `x`\n3. Add a geometry using `geom_bar`\n4. Add labels explaining the reader which column is under scrutiny\n\nWe first need to gather the names of the categorical columns. The following chunk does this in a simple way. \n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_names <- df %>% \n  select(where(is.factor))%>%\n  names()\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\nIn the next chunk, we shall build a named list of `ggplot` objects consisting of barplots. The for loop body is almost \nobtained by  cutting and pasting the recipe for the first barplot. \n\n\n::: {.callout-tip}\n\nNote an important difference: instead of something `aes(x=col)` where `col`  denotes a column in the dataframe, we shall write \n`aes(x=.data[[col]])` where `col` is a string that matches a column name. Writing `aes(x=col)` would not work. \n\nThe loop variable `col` iterates over the column names, not over the  columns themselves. \n\nWhen using `ggplot` in interactive computations, we write  `aes(x=col)`, and, under the hood, the interpreter \nuses the *tidy evaluation* mechanism that underpins `R` to map `df$col` to the `x` axis. \n\n`ggplot` functions like `aes()` use *data masking*  to alleviate the burden of the working Statistician.  \n\nWithin the context of `ggplot` programming, pronoun `.data` refers to the data layer of the graphical object. \n\n:::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_plots <- list()\n\nfor (col in col_names){\n  p <- df %>% \n  ggplot() +\n  aes(x=.data[[col]]) +     # mind the .data pronoun\n  geom_bar() +\n  labs(\n    title=\"Census data\",\n    subtitle = col\n  )\n\n  list_plots[[col]] <- p  # add the ggplot object to the list\n} \n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\nInspect the individual plots.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_temp <- list_plots[[\"REV_FOYER\"]] +\n  aes(x=forcats::fct_infreq(.data[[\"REV_FOYER\"]]))\n\np_temp\n```\n\n::: {.cell-output-display}\n![](lab-univariate-categorical_files/figure-pdf/unnamed-chunk-35-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\nIf the labels on the x-axis are not readable, we need to tweak them.\nThis amounts to modifying the `theme` layer in the `ggplot` object, \nand more specifically the `axis.text.x` attribute. \n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_temp +\n  theme(axis.text.x = element_text(angle = 45)) \n```\n\n::: {.cell-output-display}\n![](lab-univariate-categorical_files/figure-pdf/unnamed-chunk-36-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\n## Using functional programming (`lapply`, `purrr::...`)\n\nAnother way to compute the list of graphical objects replaces the `for` loop by calling a functional programming tool. This mechanism relies on the fact that in `R`, functions are first-class objects. \n\n\n::: {.callout-tip}\n\nPackage `purrr` offers a large range of tools with a clean API. Base `R` offers `lapply()`.\n\n:::\n\n\nWe shall first define a function that takes as arguments a datafame, a column name, and a title.  We do not perform any defensive programming. Call your function `foo`.\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(df, col, .title= \"WE NEED A TITLE!!!\"){\n  p <- df %>% \n  ggplot() +\n  aes(x=fct_infreq(.data[[col]])) +\n  geom_bar() +\n  labs(\n    title=.title,\n    subtitle = col\n  ) +\n  theme(axis.text.x = element_text(angle = 45)) \n  return(p)\n}\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\nFunctional programmming makes code easier to understand. \n\nUse `foo`, `lapply` or `purrr::map()` to build \nthe list of graphical objects. \n\nWith `purrr::map()`, you may use either a formula or an anonymous function. With `lapply` use an anonymous function.\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nll <- map(col_names, ~ foo(df, .x, \"Census data\"))\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(col_names, \\(x) foo(df, x, \"Census data\"))\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(col_names, \\(x)  foo(df, x, \"Census data\"))\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\n\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\nThis is essentially like executing \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nll <- list()\n\nfor (.x in col_names){\n  ll[[.x]] <- foo(df, .x, \"Census data\")\n}\n```\n:::\n\n\n\n\n\n\n:::\n\n:::::\n\n\nPackage `patchwork` offers functions for displaying collections of related plots. \n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-note title=\"solution\" collapse=\"true\"}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatchwork::wrap_plots(ll, ncol=3)\n```\n\n::: {.cell-output-display}\n![](lab-univariate-categorical_files/figure-pdf/unnamed-chunk-42-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n:::\n\n:::::\n\n\n# Useful links\n\n\n- [dplyr](https://gplot2.tidyverse.org)\n- [ggplot2](https://ggplot2.tidyverse.org)\n- [*R Graphic Cookbook*. Winston Chang. O' Reilly.](https://r-graphics.org)\n- [A blog on ggplot objects](https://www.data-imaginist.com/2017/Beneath-the-canvas/)\n- [`skimr`](https://cran.r-project.org/web/packages/skimr/vignettes/skimr.html)\n- [rmarkdown](bookdown.org/yihui/rmarkdown)\n- [quarto](https://quarto.org/docs/guide/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\n\\usepackage{longtable}\n\\usepackage{array}\n\\usepackage{multirow}\n\\usepackage{wrapfig}\n\\usepackage{float}\n\\usepackage{colortbl}\n\\usepackage{pdflscape}\n\\usepackage{tabu}\n\\usepackage{threeparttable}\n\\usepackage{threeparttablex}\n\\usepackage[normalem]{ulem}\n\\usepackage{makecell}\n\\usepackage{xcolor}\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}